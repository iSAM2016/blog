---
title: c和指针-内存管理
date: 2021-10-30 19:50:54
tags: 
categories:
- c语言
---
# 简介

C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。

系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。

用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。

# void 指针

C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。

另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。

```c
int x = 10;

void* p = &x; // 整数指针转为 void 指针
int* q = p; // void 指针转为整数指针
```
上面示例演示了，整数指针和 void 指针如何互相转换。&x是一个整数指针，p是 void 指针，赋值时&x的地址会自动解释为 void 类型。同样的，p再赋值给整数指针q时，p的地址会自动解释为整数指针。

注意，由于不知道 void 指针指向什么类型的值，所以不能用*运算符取出它指向的值。
```c
char a = 'X';
void* p = &a;
printf("%c\n", *p); // 报错
```
上面示例中，p是一个 void 指针，所以这时无法用*p取出指针指向的值。

void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息，所以放在最前面进行介绍。

# malloc() 

malloc()函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件stdlib.h。

`void* malloc(size_t size)`
它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为malloc()函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。

可以使用malloc()为任意类型的数据分配内存，常见的做法是先使用sizeof()函数，算出某种数据类型所需的字节长度，然后再将这个长度传给malloc()。
```c
int* p = malloc(sizeof(int));

*p = 12;
printf("%d\n", *p); // 12
```
上面示例中，先为整数类型分配一段内存，然后将整数12放入这段内存里面。这个例子其实不需要使用malloc()，因为 C 语言会自动为整数（本例是12）提供内存。

有时候为了增加代码的可读性，可以对malloc()返回的指针进行一次强制类型转换。

`int* p = (int*) malloc(sizeof(int));`
上面代码将malloc()返回的 void 指针，强制转换成了整数指针。

由于sizeof()的参数可以是变量，所以上面的例子也可以写成下面这样。

`int* p = (int*) malloc(sizeof(*p));`

malloc()分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括stdlib.h等多个头文件里面都有定义，所以只要可以使用malloc()，就可以使用NULL。由于存在分配失败的可能，所以最好在使用malloc()之后检查一下，是否分配成功。

```c
int* p = malloc(sizeof(int));

if (p == NULL) {
  // 内存分配失败
}

// or
if (!p) {
  //...
}
```

上面示例中，通过判断返回的指针p是否为NULL，确定malloc()是否分配成功。

malloc()最常用的场合，就是为数组和自定义数据结构分配内存。

```c
int* p = (int*) malloc(sizeof(int) * 10);

for (int i = 0; i < 10; i++)
  p[i] = i * 5;
```

上面示例中，p是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。
malloc()用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。

`int* p = (int*) malloc(n * sizeof(int));`
上面示例中，malloc()可以根据变量n的不同，动态为数组分配不同的大小。

注意，malloc()不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用strcpy()函数。
```c
char* p = malloc(4);
strcpy(p, "abc");

// or
p = "abc";
```
上面示例中，字符指针p指向一段4个字节的内存，strcpy()将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。

# free()
free()用于释放malloc()函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件stdlib.h里面。
```c
void free(void* block)
```
上面代码中，free()的参数是malloc()返回的内存地址。下面就是用法实例。
```c
int* p = (int*) malloc(sizeof(int));

*p = 12;
free(p);
```
注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用free()对该地址释放第二次。

一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用free()释放内存。
```c
void gobble(double arr[], int n) {
  double* temp = (double*) malloc(n * sizeof(double));
  // ...
}
```
上面示例中，函数gobble()内部分配了内存，但是没有写free(temp)。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用gobble()，就会留下多个内存块。并且，由于指针temp已经消失了，也无法访问这些内存块，再次使用。

# calloc()
calloc()函数的作用与malloc()相似，也是分配内存块。该函数的原型定义在头文件stdlib.h。

两者的区别主要有两点：

1. calloc()接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。

`void* calloc(size_t n, size_t size);`
calloc()的返回值也是一个 void 指针。分配失败时，返回 NULL。

2. calloc()会将所分配的内存全部初始化为0。malloc()不会对内存进行初始化，如果想要初始化为0，还要额外调用memset()函数。
```c
int* p = calloc(10, sizeof(int));

// 等同于
int* p = malloc(sizeof(int) * 10);
memset(p, 0, sizeof(int) * 10);
```
上面示例中，calloc()相当于malloc() + memset()。

calloc()分配的内存块，也要使用free()释放。


# realloc()
realloc()函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。该函数的原型定义在头文件stdlib.h。

`void* realloc(void* block, size_t size)`
它接受两个参数。

* block：已经分配好的内存块指针（由malloc()或calloc()或realloc()产生）。
* size：该内存块的新大小，单位为字节。
* realloc()可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。* * realloc()优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用memset()）。

下面是一个例子，b是数组指针，realloc()动态调整它的大小。
```c
int* b;

b = malloc(sizeof(int) * 10);
b = realloc(b, sizeof(int) * 2000);
```
上面示例中，指针b原来指向10个成员的整数数组，使用realloc()调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。

realloc()的第一个参数可以是 NULL，这时就相当于新建一个指针。
```c
char* p = realloc(NULL, 3490);
// 等同于
char* p = malloc(3490);
```
如果realloc()的第二个参数是0，就会释放掉内存块。

由于有分配失败的可能，所以调用realloc()以后，最好检查一下它的返回值是否为 NULL。分配失败时，原有内存块中的数据不会发生改变。
```c
float* new_p = realloc(p, sizeof(*p * 40));

if (new_p == NULL) {
  printf("Error reallocing\n");
  return 1;
}
```
注意，realloc()不会对内存块进行初始化。

# restrict 说明符
声明指针变量时，可以使用restrict说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。

```c
int* restrict p;
p = malloc(sizeof(int));
```
上面示例中，声明指针变量p时，加入了restrict说明符，使得p变成了受限指针。后面，当p指向malloc()函数返回的一块内存区域，就味着，该区域只有通过p来访问，不存在其他访问方式。
```c
int* restrict p;
p = malloc(sizeof(int));

int* q = p;
*q = 0; // 未定义行为
```
上面示例中，另一个指针q与受限指针p指向同一块内存，现在该内存有p和q两种访问方式。这就违反了对编译器的承诺，后面通过*q对该内存区域赋值，会导致未定义行为。
---
title: 真象还原-32位Intel微处理器编程架构
date: 2021-10-14 09:24:10
tags:
categories:
- 操作系统
---
# 保护模式
> 真象还原第4章

loader的任务是加载内核，可是内核运行在32位的保护模式下，不在是16位的实模式。先介绍一下32位Intel微处理器编程架构


Intel 32 位处理器架构简称 IA-32（Intel Architecture， 32-bit），在8086 处理器为基础发展起来的。8086 有 20 根地址线，可以寻址 1MB 内存。但是，它内部的寄存器是16 位的，无法在程序中访问整个 1MB 内存。所以，它也是第一款支持内存分段模型的处理器。还有， 8086 处理器只有一种工作模式，即实模式。当然，在那时，还没有实模式这一说。尽管 8086 是 16 位的处理器，但它也是 32位架构内的一部分。原因在于， 32 位的处理器架构是从 8086 那里发展来的，是基于 8086 的，具有延续性和兼容性。


32 位的处理器有 32 根地址线，数据线的数量是32 根或者 64 根。特别是最近最新的处理器，都是 64 根。因此，它可以访问 2的32方，即 4GB 的内存，而且每次可以读写连续的 4 字节或者 8 字节，这称为双字（Double Word）或者 4 字（Quad Word）访问。当然，如果你要按字节或者字来访问内存，也是允许的。

# 寄存器的扩展

在 16 位处理器内，有 8 个通用寄存器 AX、 BX、 CX、 DX、 SI、 DI、 BP 和 SP，其中，前 4 个还可以拆分成两个独立的 8 位寄存器来用，即 AH、 AL、 BH、 BL、 CH、 CL、 DH 和DL。

如图 32 位处理器在 16 位处理器的基础上，扩展了这 8 个通用寄存器的长度，

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014093232.jpg)

在之前的编程中用到了eax。他是32位的

32 位通用寄存器的高 16 位是不可独立使用的，但低 16 位保持同 16 位处理器的兼容性。因此，在任何时候它们都可以照往常一样使用
```
mov ah,0x02
mov al,0x03
add ax,si
```


如图所示，在 32 位模式下，为了生成 32 位物理地址，处理器需要使用 32 位的指令指针寄存器。为此， 32 位处理器扩展了 IP，使之达到 32 位，即 EIP。当它工作在 16 位模式下时，依然使用 16 位的 IP；工作在 32 位模式下时，使用的是全部的 32 位 EIP。和往常一样，即使是在 32 位模式下， EIP 寄存器也只由处理器内部使用，程序中是无法直接访问的。对 IP 和 EIP 的修改通常是用某些指令隐式进行的，这此指令包括 JMP、 CALL、 RET 和 IRET 等等

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014093942.jpg)

**从上边的两张图可以发现。通用寄存器，指针指令寄存器，标志寄存器都变为了32位。但是段寄存器还是16位**

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014104948.jpg)


在 32 位模式下，对内存的访问从理论上来说不再需要分段，因为它有 32 根地址线，可以自由访问任何一个内存位置。但是，IA-32 架构的处理器是基于分段模型的，因此， 32 位处理器依然需要以段为单位访问内存，即使它工作在 32 位模式下。

不过，它也提供了一种变通的方案，即，只分一个段，段的基地址是 0x00000000，段的长度（大小）是 4GB。在这种情况下， 可以视为不分段，即平坦模型（Flat Mode）。

每个程序都有属于自己的内存空间。在 16 位模式下，一个程序可以自由地访问不属于它的内存位置，甚至可以对那些地方的内容进行修改。这当然是不安全的，也不合法，但却没有任何机制来限制这种行为。在 32 位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址（起始地址）外，还附加了段界限、特权级别、类型等属性。当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。

在 32 位模式下，传统的段寄存器，如 CS、 SS、 DS、 ES，保存的不再是 16位段基地址，而是段的选择子，即，用于选择所要访问的段，因此，严格地说，它的新名字叫做*段选择器*。除了段选择器之外，每个段寄存器还包括一个 64 位的不可见部分，称为*描述符高速缓存器*，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。

# 基本工作模式



实模式等同于 8086 模式，实模式和 16 位保护模式统称 16 位模式。在 16 位模式下，数据的大小是 8 位或者 16 位的；控制转移和内存访问时，偏移量也是 16 位的。


在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的*平坦模式*。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。 32 位保护模式兼容 80286 的 16 位保护模式。

32 位模式特指 IA-32 处理器上的 32 位保护模式。不存在所谓的 32 位实模式，

# 线性地址

为 IA-32 处理器编程，访问内存时，需要在程序中给出段地址和偏移量，因为分段是 IA-32架构的基本特征之一。传统上，段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址（Effective Address， EA），在指令中给出有效地址的方式叫做寻址方式（Addressing Mode）。

比如：`inc word [bx+si+0x06]`


IA-32 处理器支持多任务。在多任务环境下，任务的创建需要分配内存空间；当任务终止后，还要回收它所占用的内存空间。在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。

为了解决这个问题， IA-32 处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为 4KB，通过使用页，可以简化内存管理。

如图 所示，当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（ Linear Address），线性地址还要经页部件转换后，才是物理地址

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014101548.jpg)

线性地址的概念用来描述任务的地址空间。 IA-32 处理器上的每个任务都拥有4GB 的虚拟内存空间，这是一段长 4GB 的平坦空间，就像一段平直的线段，因此叫线性地址空间。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是*线性地址*

# 流水线

处理器可以做很多事情，换言之，能够执行各种不同的指令，完成不同的功能，但这些事情大都不会在一个时钟周期内完成。执行一条指令需要从内存中取指令、译码、访问操作数和结果，并进行移位、加法、减法、乘法以及其他任何需要的操作。

为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是流水线（Pipe-Line）技术。

比如，一条指令的执行过程分为取指令、 译码和执行三个步骤，而且假定每个步骤都要花1 个时钟周期，那么，如图 所示，如果采用顺序执行，则执行三条指令就要花 9 个时钟周期，每 3 个时钟周期才能得到一条指令的执行结果；如果采用 3 级流水线，则执行这三条指令只需 5 个时钟周期，每隔一个时钟周期就能得到一条指令的执行结果

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014102202.jpg)

# 保护模式（32位）之寻址模式

我们已经了解了在实模式下的寻址方式，进入保护模式下，寻址方式有了很大的改变。

实模式下的寻址
```
mov ax,[si]
mov ax,[di]
mov ax,[bx]
mov ax,[bx+si]
mov ax,[bx+si+0x1234]
```
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014111518.jpg)

在 32 位模式下，默认使用 32 位宽度的寄存器。如：`mov eax,ebx`
如果指令中使用了立即数，那么，该数值默认是 32 位的：
```
mov ecx,0x55 ;ECX←0x00000055
```
还有，如果指令中的操作数是指向内存单元的地址，那么，该地址默认是 32 位的段内偏移地址，或者叫段内偏移量：
```
mov edx,[mem] ;mem 是一个 32 位的段内偏移地址
```

保护模式下 偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子，注意比例因子是1，2，4，8

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014111813.jpg)

具体形式如下代码。
```
mov eax， [eax+edx*8+0x12345678]
mov eax， [eax+edx*2+0x8]
mov eax， [ecx*4+0x1234]
```
虽然 esp 无法用作变址寄存器，但其可用于基址寄存器。所以，如下代码是正确的。
```
mov eax， [esp]
mov eax， [esp+2]
```

# 操作数大小的指令前缀

cpu运行莫奥豪斯有实模式和保护模式两种，需要兼顾这两种模式

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014112756.jpg)

如图 10-7 所示，每一条处理器指令都可以拥有前缀，比如重复前缀（REP/REPE/ REPNE）、段超越前缀（如 ES：）、总线封锁前缀（LOCK）等。前缀是可选的，每个前缀的长度是 1 字节，每条指令可以有 1～4 个前缀，或者不使用前缀。

前缀（如果有的话）的后面是操作码部分，指示执行什么样的操作，比如传送、加法、减法、乘法、除法、移位等。根据指令的不同，操作码的长度是 1～3 字节。同时，操作码还可以用来指示操作的字长，即数据宽度为字节还是字。

操作码之后是操作数类型和寻址方式部分。这部分是可选的，简单的指令不包含这一部分，稍微复杂一点的指令，这一部分只有 1 字节；最复杂的指令，可能有 2 字节。这部分给出了指令的寻址方式，以及寄存器的类型（用的是哪个寄存器）。

指令的最后是立即数和偏移量。如果指令中使用了立即数，那么立即数就在这一部分给出；如果指令使用了带偏移量的寻址方式，如：
```
mov cx,[0x2000]
mov ecx,[eax+ebx*8+0x02]
```
偏移量 0x2000 和 0x02 也在这部分出现。取决于具体的指令，立即数可以是 1、 2 或者 4 字节，偏移量部分与此相同


在编写程序的时候，就应当考虑到指令的运行环境。为了指明程序的默认运行环境，编译器提供了伪指令 bits，用于指明其后的指令应该被编译成 16 位的，还是 32 位的。 比如：

```
bits 16
mov cx,dx ;89 D1
mov eax,ebx ;66 89 D8

bits 32
mov cx,dx ;66 89 D1
mov eax,ebx ;89 D8
```
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014142739.jpg)

## 反转前缀 

### 0x66 操作数大小反转前缀
模式之间可以互相使用对方环境下的资源。比如， 16 位实模式下可以用 32 位保护模式下的寄存器。如果要用另一模式下的操作数大小，需要在指令前添加指令前缀 0x66，将当前模式临时改变成另一模式。这就是反转的意义，不管是当前模式是什么，总是转变成相反的运行模式。

比如，在指令中添加了 0x66 (就是那个e)反转前缀之后：

* 假设当前运行模式是 16 位实模式，操作数大小将变为 32 位。
* 假设当前运行模式是 32 位保护模式，操作数大小将变为 16 位。

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014143302.jpg)

### 0x67 寻址方式反转前缀

不同模式之间不仅可以使用对方模式下的操作数，还可以使用对方模式下的寻址方式。

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211014144701.jpg)


## 保护模式之指令扩展

在 16 位的实模式下， CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数

对于 loop 指令，实模式下要用 cx 寄存器来存储循环次数，在保护模式下，要用 ecx。

mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。其中“寄存器/内存”是乘数。

* 如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。
* 如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。
* 如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx： eax，其中 edx 是积的高 32 位， eax 是积的低 32 位。

有符号数相乘指令 imul 也是一样，不再说明。

对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。
* 如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。
* 如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。
* 如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

对于 push 指令，需要根据其操作数的类型，分别讨论，操作数类型如下。
* 立即数。
* 寄存器。
* 内存。

先看第 1 种情况，对于立即数来说，可以分别压入 8 位、 16 位、 32 位数据。指令格式是：
* push 8 位立即数
* push 16 位立即数
* push 32 位立即数
  
虽说可以压入 8 位立即数，但实际上，对于 CPU 来说，出于对齐的考虑，操作数要么是 16 位，要么是 32 位，所以 8 位立即数会被扩展成各模式下的默认操作数宽度，即实模式下 8 位立即数扩展成为 16 位后再入栈，保护模式下扩展成为 32 位后再入栈。

在实模式环境下：
* 当压入 8 位立即数时， 由于实模式下默认操作数是 16 位， CPU 会将其扩展为 16 位后再将其入栈， sp-2。
* 当压入 16 位立即数时， CPU 会将其直接入栈， sp-2。
* 当压入 32 位立即数时， CPU 会将其直接入栈， sp-4

在保护模式下，同样是这些压入立即数的指令，栈指针会有怎样的变化呢
* 当压入 8 位立即数时，由于保护模式下默认操作数是 32 位， CPU 将其扩展为 32 位后入栈， esp 指针
减 4。
* 当压入 16 位立即数时， CPU 直接压入 2 字节， esp 指针减 2。
* 当压入 32 位立即数时， CPU 直接压入 4 字节， esp 指针减 4。


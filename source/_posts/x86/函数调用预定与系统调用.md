---
title:  真象还原-函数调用预定与系统调用
date: 2021-10-19 11:31:56
tags:
categories:
- 操作系统
---
# 函数调用约定

由于我们将c语言和汇编语言结合，所以会存在汇编代码和c代码相互理解调用的问题。

函数`调用约定`调用约定从字面上理解，他是调用函数的一套约定。 参数的传递方式，参数是存放在栈中

其优点如下:
1. 每个进程都有自己的栈
2. 参数的内存地址不用花精力去维护，已经有栈机制自动帮我们维护参数储存的问题解决了
   
那么接下来讨论另外两个问题
1. 参数存储在栈中，那么谁来负责回收参数所占的栈空间，是调用者？还是被调用者
2. 当参数很多的时候后，主调函数将参数以什么样的顺序传递

上面两个问题就涉及到具体的调用规定了

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/v2-31fd32d77c9d7c8cd9f0c3ecbe05819a_.jpg)

在这些调用约定中，我们最常用是以下几种约定
1. cdecl
2. stdcall
3. thiscall
   
* cdecl 是c默认的调用约定。
* stdcall 他是微软Win32 API的一准标准，我们常用的回调函数就是通过这种调用方式
* thiscall 是c++中非静态类成员函数的默认调用约定

# c库函数与系统调用  系统调用
 汇编语言和c语言编程分为两大类
 
1. 单独的汇编文件与单独的c语言文件编译成目标文件后，一起链接成可执行文件。（混合编程）
2. 在c语言中嵌入汇编代码，直接编译成可执行程序（内联汇编）

系统调用是linux内核提供的一套子程序，主要是为了实现在用户态不能实现的功能，比如说最常见的读写硬盘文件，这些读写的方法肯定不能由用户程序来编写，而且用户程序也没有权限去直接操控硬件，这就需要操作系统的支持，需要操作系统提供读写硬盘的接口，即系统调用。

系统调用的入口只有一个，即第0x80号中断，通过eax指定子功能号。在linux中，系统调用是定义在 /usr/include/asm-generic-unistd.h 中

调用系统调用有两种方式

1. 通过操作系统提供的库函数进行系统调用
2. 直接通过0x80中断与系统通信

我们想要自制kernel的话第一条路肯定走不通，因为没有库函数供我们调用，库函数都是我们自己写的。

通过中断的方式进行系统调用需要了解一下系统调用输入参数的传递方式

当输入的参数小于等于5个时，linux用寄存器传递参数。当输入的参数大于5个时，把参数按照顺序放入连续的内存中，并把这块内存的首地址放入ebx中

通过寄存器传递参数时,eax存放子功能号,ebx存放第一个参数,ecx存放第二个参数,edx存放第三个参数,esi存放第四个参数,edi存放地五个参数






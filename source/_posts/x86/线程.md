---
title: 线程
date: 2022-01-26 14:09:49
tags:
categories:
- 操作系统
---
# 执行流
> 在本节我们只考虑单核

过去，计算机只有 1 个处理器 ，任务的执行都是串行的，一个任务彻底执行完成后才能开始下一个任务。

多道程序设计的方式，使处理器在所有任务之间来回切换，这样就给用户一种所有任务并行运行的错觉，这称为“伪并行”

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220129195738.jpg)

任务调度器来实现伪并行。

任务调度器就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。

调度器在内核中维护一个任务表（也称进程表、线程表或调度表） ，然后按照一定的算法， 从任务表中选择一个任务，然后把该任务放到处理器上运行，当任务运行的时间片到期后，再从任务表中找另外一个任务放到处理器上运行，周而复始，让任务表中的所有任务都有机会运行。

# 多任务弊端

对于所有任务来说，在不考虑阻塞的情况下，无论是在哪种系统上，它们“自身指令”总共的执行时间之和应该是一致的。但是，在多任务系统中，任务切换是软件完成的，切换工作本身必然要消耗处理器周期，因此所有任务的总共执行时间反而更长了。

如图所示，四个任务：A、B、C、D 执行的总时间， 在多任务操作系统上的时间更长，其中右图中虚线的部分是任务切换的时间成本。

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220202163634.jpg)

# 执行流
执行流就是一段逻辑上独立的指令区域，是人为给处理器安排的处理单元。

指令是具备“能动性”的数据，因此只有指令才有“执行”的能力，它相当于是动作的发出者，由它指导处理器产生相应的行为。

指令是由处理器来执行的，它引领处理器“前进”的方向，用“流”来表示处理器中程序计数器的航向，借此比喻处理器依次把此区域中的指令执行完后，所形成的像河流一样曲直不一的执行轨迹、执行路径（由顺序执行指令及跳转指令导致）

执行流对应于代码， 大到可以是整个程序文件， 即进程， 小到可以是一个功能独立的代码块， 即函数， 而线程本质上就是函数。

执行流是独立的，它的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源， 这是 Intel 处理器在硬件上规定的，其实这正是执行流的上下文环境。

要想构造一个执行流， 就要为其提供这一整套的资源。任何代码块，无论大小都可以独立成为执行流，只要在它运行的时候，我们提前准备好它所依赖的上下文环境就行，这个上下文环境就是它所使用的寄存器映像、栈、内存等资源。

在任务调度器的眼里，只有执行流才是调度单元，即处理器上运行的每个任务都是调度器给分配的执行流，只要成为执行流就能够独立上处理器运行了，也就是说处理器会专门运行执行流中的指令。 执行流就是进程和线程

# 线程
线程的本质是函数的另一种执行方式，线程是一套机制，能够让所运行的函数能够以调度单元的身份独立上处理器进行执行，函数能够独立执行，可以让多个函数以并行的方式执行给程序提提速

**普通的函数执行是加在程序中间进行执行的，线程的函数执行是独立出来单独让CPU处理**


进程是操作系统对一个正在运行的程序的一种抽象。
<!-- TODO: csapp: 第一张 对进程的描述 -->

# 进程与线程的关系区别

程序是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像。

进程是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈，使用的寄存器等。

对于处理器来说，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是处理器的执行单位，或者称为调度单位，它们就是线程。

可以认为，线程是在进程基础之上的二次并发。

线程是在进程之后才提出的概念， 在没有线程之前，进程就是理所当然的执行流，或者说进程只是一个大的执行流。

在有了线程的概念后 ，执行流便专指粒度更细的线程，因此线程是最小的执行单元。

处理器执行任何程序，其过程都是一步步跟随程序中下一步要执行的指令，所以说程序都有执行流。

纯粹的进程实际上就相当于单一线程的进程， 也就是前面所说的单线程进程。进程中若显式创建了多个线程时，就会有多个执行流，也就是多线程进程

*任务其实就是执行流，要么是大的执行流—单线程的进程，要么是小的执行流—线程*

**进程和线程的关系:**

进程拥有整个地址空间， 其中包括各种资源， 而进程中的所有线程共享同一个地址空间，原因很简单，因为这个地址空间中有线程运行所需要的资源。简单的公式： 进程 = 资源 + 线程。进程独自拥有整个地址空间，在这个空间中装有线程运行所需的资源，所以地址空间相当于资源容器

根据进程内线程的数量，进程可分为：
1. 单线程进程
2. 多线程进程
执行流、调度单位、运行实体等概念都是针对线程而言的，线程才是解决问题的思路、步骤，它是具有能动性的指令，因此只有它才能上处理器运行，即一切执行流其实都是线程，因为任何时候进程中都至少存在一个线程。


# 进程，线程的状态
操作系统把进程（线程）“执行过程”中所经历的不同阶段归为几类：

* 阻塞态：等待外界条件
* 就绪态：外界条件就绪
* 运行态：正在运行的进程

状态的变化，如图
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220204135238.jpg)

通常这种状态的转变是由操作系统的调度器及相关代码负责的.

进程或线程等各种执行流都是人为创造的代码块，因此执行流的各种状态也是人为划分的

# PCB 程序控制块
PC是进程的身份证，用来记录与此进程相关的信息。
PCB 的结构如图：

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220204140028.jpg)

每个进程都有自己的 PCB，所有 PCB 放到一张表格中维护，这就是进程表，调度器可以根据这张表选择上处理器运行的进程。
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220204140324.jpg)

# 实现线程的两种方式

实现线程有两种方式：在用户空间实现线程或者在内核空间实现线程

* 在用户空间实现线程：可移植性强，对处理器来说，会进行进程级别的调度，无法精确到进程中自己实现的具体线程中去
* 在内核空间实现线程(重点)：可以以线程级别来调度执行流，效率更高

如果是程序内实现线程，那处理器调度任务的时候以进程为单位进行，一个进程分配的时间片还是那么多

如果是内核里实现线程，这处理器调度任务的时候以线程为单位进行，一个进程内如果有多个线程，则这个进程占用的时间片会多一些，达到提速的效果

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220204143848.jpg)

# 在内核空间实现线程

`struct intr_stack` 定义了程序的中断栈，无论是进程，还是线程，此结构用于中断发生时保护程序的上下文环境。

在 C 语言层面，函数的执行都是由调用者发起调用的，这通过 call 指令完成，此指令会在栈中留下返回地址。因此被调用的函数在执行时， 会认为调用者已经把返回地址留在栈中，而且是在栈顶的位置。也就是说当进入到被调用函数中执行时，栈中的情形应该如图所示。

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20220209085917.jpg)

被调用者是 eip 所指向的 kernel_thread 函数，当 kernel_thread 开始执行时，处理器会认为当前栈顶 “应该是” 调用者的返回地址， 因此它会从当前栈顶+4 的位置找参数

thread_stack线程栈，有两个作用，主要体现在eip上：

* 首次运行时，eip用来保存待运行的函数的地址
* 切换任务时，eip用来保存任务切换后的新任务的返回地址

其他4个成员是ABI（程序二进制接口）的规定，在函数调用前后这几个寄存器的值不能改变，一般由编译器负责生产，但是自己写汇编代码给C调用的时候，要手动完成这件事

”仅供第一次被调度上使用“这一段注释之后的三个内容：
```c
void (*unused_retaddr);    			
thread_func* function;              
void* func_arg;    
```
因为是用ret进行跳转执行，跳转执行后，使用参数中的函数地址+函数参数进行函数调用，函数调用的时候通常会使用call，这里没用call指令，所以得按照call指令的入栈形式来装填栈才行，第一个是返回地址，接下来是参数，所以这里需要一个占位符

下次再回到这个线程进行执行的时候，就是跳转过来的时候了，跳转的时候会重新指定栈顶位置，所以之后就再也用不上了

```c
// thread/thread.h
#ifndef __THREAD_THREAD_H
#define __THREAD_THREAD_H
#include "stdint.h"

/* 自定义通用函数类型，他将在很多线程函数中作为形参类型*/
typedef void thread_func(void *);

/* 进程或线程的状态*/
enum task_status
{
    TASK_RUNNING,
    TASK_READY,
    TASK_BLOCKED,
    TASK_WAITING,
    TASK_HANGING,
    TASK_DIED
};
/************** 中断栈 intr_stack *********************
 * 此结构用于中断发生是保护程序（线程或进程）的上下文环境：
 * 进程或线程被外部中断或软终端打断时， 会按照此结构压入上下文
 * 寄存器， intr_exit 中的出栈操作是次结构的逆操作
 * 此栈 在线程自己的内核栈中位置固定，所以在页的最顶端
 *
 **************************************************/
struct intr_stack
{
    uint32_t vec_no; //  kernel.S 宏 VECTOR中 pus h % 1 压入的中断号
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp_dummy; //  虽然 pushad 把 esp 也压入，但 esp是不断变化的，所以会被 popad 忽略
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;
    uint32_t gs;
    uint32_t fs;
    uint32_t es;
    uint32_t ds;
    /*以下由 cpu 从低特权级进入高特权级时压入 */
    uint32_t err_code;
    // err_code 会被压入在 eip 之后
    void (*eip)(void);
    uint32_t cs;
    uint32_t eflags;
    void *esp;
    uint32_t ss;
};
/****************** 线程栈 thread_stack *****************
 * 线程自己的栈， 用于存储线程中待执行的函数
 * 此结构在线程自己的内车栈中位置不固定
 * 仅用在switch_to时保存线程的环境
 * 实际位置取决于实际运行情况
 *******************************************************/
struct thread_stack
{
    // 保护寄存器的值  在switch_to函数中在恢复这4个值
    uint32_t ebp;
    uint32_t ebx;
    uint32_t edi;
    uint32_t esi;
    /* 线程第一次执行时候， eip 指向待调用的函数kernel_thread 其他时候，
    eip 是指向switch_to 的返回地址*/
    void (*eip)(thread_func *func, void *func_arg);
    /******* 以下仅供第一次被调度上cpu 时使用*********/
    /* 参数unused_ret 只为占位置成熟为返回地址*/
    void(*unused_retaddr);
    thread_func *function; // 由kernel_thread 所调用的函数名
    void *func_arg;        // 由kernel_thread 所调用的函数所需的参数
};

/*进程或线程的pcb 程序控制块*/
struct task_struct
{
    uint32_t *self_kstack;   // 各个内核线程都用自己的内核栈
    enum task_status status; // 用于记录线程状态，其类型便是前面定义的枚举结构enum task_status
    uint8_t priority;        // 线程优先级，进程或线程都要有个优先级，此优先级咱们用来决定进程或线程的时间片，即被调度到处理器上的运行时间
    char name[16];           //用于记录任务（线程或进程）的名字，长度是 16
    uint32_t stack_magic;    //栈的边界标记，用于检测栈的溢出
};

#endif
```


请大伙注意，无论是进程或线程的 PCB，这都是给内核调度器使用的结构，属于内核管理的数据， 因此将来用户进程的 PCB 也依然要从内核物理内存池中申请。

```c
// thread/thread.c
#include "thread.h"
#include "stdint.h"
#include "string.h"
#include "global.h"
#include "memory.h"

#define PG_SIZE 4096
/*****
 * 由 kernel_therad 去执行 function(func_arg)
 * 进入函数kernel_thread 时， 栈顶出是返回地址，因此栈顶+4的位置保存的是function
 * 栈顶+8保存的是func_arg
 */

static void kernel_thread(thread_func *function, void *func_arg)
{
    function(func_arg);
}
/**
 * @brief 初始化线程 thread_stack, 将待执行的函数和参数放到 thread_stack 中相应的位置
 *
 * @param pthread
 * @param function
 * @param func_arg
 */
void thread_create(struct task_struct *pthread, thread_func function, void *func_arg)
{ /**
   * 先预留中断使用栈的空间，可见thread.h定义的结构
   */
    pthread->self_kstack -= sizeof(struct intr_stack);

    /**
     * 在预留出线程空间，可见thread.h中定义
     */
    pthread->self_kstack -= sizeof(struct thread_stack);
    struct thread_stack *kthread_stack = (struct thread_stack *)pthread->self_kstack;
    kthread_stack->ebp = kernel_thread;
    kthread_stack->function = function;
    kthread_stack->func_arg = func_arg;
    kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
}

// 初始化线程基本信息
// 待初始化线程指针（PCB），线程名称，线程优先级
void init_thread(struct task_struct *pthread, char *name, int prio)
{
    memset(pthread, 0, sizeof(*pthread)); //清零
    strcpy(pthread->name, name);          //给线程的名字赋值

    pthread->status = TASK_RUNNING; //线程的状态
    pthread->status = TASK_READY;

    // self_kstack 是线程自己在内核态下使用的栈顶地址
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE);
    pthread->stack_magic = 0x19870916; // 自定义魔数
}
// 线程所执行的函数是 function(func_arg)
struct task_struct *thread_start(char *name,           //线程名
                                 int prio,             //优先级
                                 thread_func function, //要执行的函数
                                 void *func_arg)       //函数的参数
{
    // PCB 都位于内核空间, 包括用户进程的 PCB 也是在内核空间
    // 由于 get_kernel_page 返回的是页的起始地址， 故 thread 指向的是 PCB 的最低地址。
    struct task_struct *thread = get_kernel_pages(1); //申请一页内核空间存放PCB

    init_thread(thread, name, prio);           //初始化线程
    thread_create(thread, function, func_arg); //创建线程

    asm volatile("movl %0, %%esp; \
                  pop %%ebp; \
                  pop %%ebx; \
                  pop %%edi; \
                  pop %%esi; \
                  ret;" ::"g"(thread->self_kstack)
                 : "memory");

    return thread;
}

```

main.c 

```c
#include "print.h"
#include "init.h"
#include "debug.h"
#include "memory.h"
#include "thread.h"

void k_thread_a(void *);

void main(void)
{
   put_str("I am kernel\n");
   init_all();
   // ASSERT(1 == 2);
   // asm volatile("sti"); // 为演示中断处理,在此临时开中断
   // 从内核物理内存池中申请内存，成功返回虚拟地址，失败返回NULL
   // void *addr = get_kernel_pages(5);
   // put_str("\n get_kernel_page start vaddr is:");
   // put_int((uint32_t)addr);

   thread_start("k_thread_a", 31, k_thread_a, "hello world\n");

   put_str("\n");
   while (1)
      ;
   return 0;
}

void k_thread_a(void *arg)
{
   char *para = arg;
   while (1)
   {
      put_str(para);
   }
}

```

makefile 文件中添加 

```
LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/


$(BUILD_DIR)/thread.o
##############     c代码编译     ###############

$(BUILD_DIR)/thread.o: thread/thread.c thread/thread.h lib/stdint.h \
        kernel/global.h lib/kernel/bitmap.h kernel/memory.h lib/string.h \
        lib/stdint.h lib/kernel/print.h kernel/interrupt.h kernel/debug.h
	$(CC) $(CFLAGS) $< -o $@

```


* 执行 `sudo make all`
* 执行bochs文件。
  1. 执行文件`bin/bochs -f bochsrc.disk`
  2. `输入c` + 回车

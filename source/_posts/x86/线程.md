---
title: 线程
date: 2022-01-26 14:09:49
tags:
categories:
- 操作系统
---
# 执行流
> 在本节我们只考虑单核

过去，计算机只有 1 个处理器 ，任务的执行都是串行的，一个任务彻底执行完成后才能开始下一个任务。

多道程序设计的方式，使处理器在所有任务之间来回切换，这样就给用户一种所有任务并行运行的错觉，这称为“伪并行”

![](20220129195738.jpg)

任务调度器来实现伪并行。

任务调度器就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。

调度器在内核中维护一个任务表（也称进程表、线程表或调度表） ，然后按照一定的算法， 从任务表中选择一个任务，然后把该任务放到处理器上运行，当任务运行的时间片到期后，再从任务表中找另外一个任务放到处理器上运行，周而复始，让任务表中的所有任务都有机会运行。

# 多任务弊端

对于所有任务来说，在不考虑阻塞的情况下，无论是在哪种系统上，它们“自身指令”总共的执行时间之和应该是一致的。但是，在多任务系统中，任务切换是软件完成的，切换工作本身必然要消耗处理器周期，因此所有任务的总共执行时间反而更长了。

如图所示，四个任务：A、B、C、D 执行的总时间， 在多任务操作系统上的时间更长，其中右图中虚线的部分是任务切换的时间成本。

![](20220202163634.jpg)

# 执行流
执行流就是一段逻辑上独立的指令区域，是人为给处理器安排的处理单元。

指令是具备“能动性”的数据，因此只有指令才有“执行”的能力，它相当于是动作的发出者，由它指导处理器产生相应的行为。

指令是由处理器来执行的，它引领处理器“前进”的方向，用“流”来表示处理器中程序计数器的航向，借此比喻处理器依次把此区域中的指令执行完后，所形成的像河流一样曲直不一的执行轨迹、执行路径（由顺序执行指令及跳转指令导致）

执行流对应于代码， 大到可以是整个程序文件， 即进程， 小到可以是一个功能独立的代码块， 即函数， 而线程本质上就是函数。

执行流是独立的，它的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源， 这是 Intel 处理器在硬件上规定的，其实这正是执行流的上下文环境。

要想构造一个执行流， 就要为其提供这一整套的资源。任何代码块，无论大小都可以独立成为执行流，只要在它运行的时候，我们提前准备好它所依赖的上下文环境就行，这个上下文环境就是它所使用的寄存器映像、栈、内存等资源。

在任务调度器的眼里，只有执行流才是调度单元，即处理器上运行的每个任务都是调度器给分配的执行流，只要成为执行流就能够独立上处理器运行了，也就是说处理器会专门运行执行流中的指令。 执行流就是进程和线程

# 线程
<!--TODO: 参考pdf  应该先介绍进程 -->
线程的本质是函数的另一种执行方式，线程是一套机制，能够让所运行的函数能够以调度单元的身份独立上处理器进行执行，函数能够独立执行，可以让多个函数以并行的方式执行给程序提提速

**普通的函数执行是加在程序中间进行执行的，线程的函数执行是独立出来单独让CPU处理**

# 进程与线程的关系区别

程序是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像。

进程是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈，使用的寄存器等。

对于处理器来说，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是处理器的执行单位，或者称为调度单位，它们就是线程。

可以认为，线程是在进程基础之上的二次并发。

线程是在进程之后才提出的概念， 在没有线程之前，进程就是理所当然的执行流，或者说进程只是一个大的执行流。

在有了线程的概念后 ，执行流便专指粒度更细的线程，因此线程是最小的执行单元。

处理器执行任何程序，其过程都是一步步跟随程序中下一步要执行的指令，所以说程序都有执行流。

纯粹的进程实际上就相当于单一线程的进程， 也就是前面所说的单线程进程。进程中若显式创建了多个线程时，就会有多个执行流，也就是多线程进程

*任务其实就是执行流，要么是大的执行流—单线程的进程，要么是小的执行流—线程*

**进程和线程的关系:**

进程拥有整个地址空间， 其中包括各种资源， 而进程中的所有线程共享同一个地址空间，原因很简单，因为这个地址空间中有线程运行所需要的资源。简单的公式： 进程 = 资源 + 线程。进程独自拥有整个地址空间，在这个空间中装有线程运行所需的资源，所以地址空间相当于资源容器

根据进程内线程的数量，进程可分为：
1. 单线程进程
2. 多线程进程
执行流、调度单位、运行实体等概念都是针对线程而言的，线程才是解决问题的思路、步骤，它是具有能动性的指令，因此只有它才能上处理器运行，即一切执行流其实都是线程，因为任何时候进程中都至少存在一个线程。

# 进程，线程的状态
操作系统把进程（线程）“执行过程”中所经历的不同阶段归为几类：

* 阻塞态：等待外界条件
* 就绪态：外界条件就绪
* 运行态：正在运行的进程

状态的变化，如图
![](20220204135238.jpg)

通常这种状态的转变是由操作系统的调度器及相关代码负责的.

进程或线程等各种执行流都是人为创造的代码块，因此执行流的各种状态也是人为划分的

# PCB 程序控制块
PC是进程的身份证，用来记录与此进程相关的信息。
PCB 的结构如图：

![](20220204140028.jpg)

每个进程都有自己的 PCB，所有 PCB 放到一张表格中维护，这就是进程表，调度器可以根据这张表选择上处理器运行的进程。
![](20220204140324.jpg)

# 实现线程的两种方式

实现线程有两种方式：在用户空间实现线程或者在内核空间实现线程

* 在用户空间实现线程：可移植性强，对处理器来说，会进行进程级别的调度，无法精确到进程中自己实现的具体线程中去
* 在内核空间实现线程(重点)：可以以线程级别来调度执行流，效率更高

如果是程序内实现线程，那处理器调度任务的时候以进程为单位进行，一个进程分配的时间片还是那么多

如果是内核里实现线程，这处理器调度任务的时候以线程为单位进行，一个进程内如果有多个线程，则这个进程占用的时间片会多一些，达到提速的效果

![](20220204143848.jpg)

# 在内核空间实现线程

# 双向链表

在内核中也要用到队列，比如进程的就绪队列、锁的等待队列等，双向链表维护内核中的各种队列。
`lib/kernel/list.h`
```c
#ifndef __LIB_KERNEL_LIST_LIST_H
#ifndef __LIB_KERNEL_LIST_LIST_H
#include "global.h"

#define offset (struct_type, member) (int)(&((struct type *) 0)->member)
#define elem2entry (struct_type, struct_member_name, elem_ptr) \ 
        (struct_type*)((int)  elem_ptr - offset(struct_type, struct_member_name))

/**** 定义链表结构成员结构***
* 节点中不需要数成员， 只要求前驱和后继节点指针
*/
struct list_elem {
    struct list_elem* prev; // 前驱节点
    struct list_elem* next; // 后续节点
}
/* 链表结构，用来实现队列*/
struct list {
      /* head 是队首，是固定不变的，不是第一个元素，第一个元素为haed.next*/
      struct list_elem head;
      /* tail 是队尾 同样是固定不变的*/
      struct list_elem tail;
}
 /*定义函数类型 function ，用于在 list traversal 中做回调函数＊／

typedef bool (function) (struct list elem 食， int arg); 

 void list_init (struct list*); 
 void list_insert_before (struct list_elem* before, struct list_elem* elem); 
 void list__push(struct list plist, struct list_elem* ele_m); 
 void list_iterate(struct list* plist); 
 void list_append(struct list plist struct list_elem* elem); 
 void list_remove(struct list_elem* pelem); 
  struct list_elem list__pop(struct list* plist); 
 bool list_empt¥(struct list* plist); 
 uint32_t list_len.(struct list* plist); 
 struct list_elem* list_traversal(struct list* plist, function func, int arg); 
 bool elem_find(struct list .. plist, struct list_elem* obj~elem); 
 #endif

```

系统中有些数据是公共资源，对于它的修改应该保证是原子操作。

访问公共资源的程序片段叫临界区，临界区通常是指在不同线程中的、修改同一公共资源的指令区域。临界区中的代码应该属于原子操作，要么不执行，要么就全部执行完（就像数据库
中的事务一样〉，说白了就是怕某线程临界区中的代码未全部执行完就被换下处理器，然后另一个线程的临界区代码又对此公共资源有读写，于是造成公共资源数据的错误，这就是资源竞争的问题

```c
#include "list.h"
#include "interrupt.h"

/* 初始化双向链表 把表头和表尾链接起来*/
void list_init (struct list* list){
    list->head.prev = NULL;
    list->head.next = &list->tail;
    list->tail.prev = &list->head;
    list->til.next = NULL;
}
/* 把链表元素elem 插入在元素before 之前*/
void list_insert_before(struct list_elem* before, struct list_elem * elem){
  enum inter_status old_status = intr_disabled();
 /*将 before 前驱元素的后继元素更新为 elem ，暂时使 before 脱离链表＊／
 before->prev->next =elem; 
 
 /*新 elem 自己的前驱结点为 before 的前驱，
 /*更新 elem 自己的后继结束、为 before ，于是 before 又回到链表
 elem->prev = before->prev; 
 elem->next = before; 
 
 /*更新 before 的前驱结点为 elem */ 
 before->prev = elem; 
 
 intr_set_status (old_status):
}
/* 添加元素到列表队首 类似push 操作*/
void list_push(struct list* plist, struct list_elem* elem){
    list_insert_before(plist->head.next, elem); // 在队头插入elem
}

/* 追加元素到链表队尾，类似队列的先进先出操作*/
void list_append(struct list* plist, struct list_elem * elem){
    list_inset_before(&plist->tail, elem); // 在队尾的前面插入
}
/* 使元素pelem 脱离链表*/
void list_remove(struct list_elem* pelem){
    enum intr_status old_status = intr_disable();
    
    pelem->prev->next = pelem->next;
    pelem->next->prev = pelem->prev;
    
    intr_set_status(old_status);

}
/*从链表中查找元素obj_elem 成功时返回true 失败时返回false*/
bool elem_find(stuct list* plist, struct list_elem* obj_elem){
  struct list_elem* elem = plist->head.next;
  whild(elem != &plist->tail){
        if (elem == obj_elem){
            return true;
        }
  }
  return false;
}

/*把列表 plist 中的每个元素 elem arg 传给回调函数 func,
* arg func 用来判断 elem 是否符合条件．
* 本函数的功能是遍历列表内所有元素，逐个判断是否有符合条件的元素。 
* 找到符合条件的元素返回元素指针，否则返回 NULL 
*/ 
struct list_elem* list_traversal (struct list* plist, function func, int arg) { 
struct list_elem* elem = plist->head.next; 

/*如果队列为空，就必然没有符合条件的结点，故直接返回 NULL */ 
    if (list_empty(plist)) { 
       return NULL; 
    }
    while (elem != &plist->tail) { 
      if (func (elem, arg)) { 
// func 返回 ture ，则认为该元素在回调函数中符合条件，命中，故停止继续遍历
          return elem; 
       } //若因调函数 func 返回 true ，则继续遍历
      elem = elem->next; 
    } 
    return NULL; 
} 

/* 返回链表长度*/
uint32_t list_len (struct list* plist) ( 
    struct list_elem* elem = plist->head.next; 
    uint32 t length = 0; 
    while (elem != &plist->tail) { 
        length++; 
        elem = elem->next; 
    } 
    return length; 
} 
 
/*判断链表是否为空，空时返回 true ，否则返回 false */I 
bool list_empty(struct list* plist) { //判断队列是否为空
    return (plist->head.next == &plist->tail? true:false); 
}
```

# 多线程调度 


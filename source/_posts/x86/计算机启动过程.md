---
title: 计算机启动过程
date: 2021-10-12 13:57:25
tags:
categories:
---

# 计算机启动过程 
> 真象还原-第二章

![](https://i0.hdslb.com/bfs/article/88ed8ff0050fa4b9b781c1d9620bdcaade7c8dd1.png@942w_498h_progressive.webp)

第一步当然是供电.开机后，BIOS会确认硬件是否正常运行，没有问题就会启动引导程序，引导程序的功能就是把硬盘等记录的os加载到内存中运行。虽然启动应用程序是os的功能。但是os不能自己启动字节，而是通过引导来启动

Bootstrap的愿意是指靴子上部的”拔靴带“ BIOS 这样的小程序（拔靴带），可以带动（启动）操作系统的大程序（靴子） 所以由此得名。虽然操作系统运行以后，程序不用关心BIOS及引导程序了，但是需要知道他们的存在
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211012141645.jpg)

1. BIOS 
2. 主引导程序MBR
3. 硬盘启动
4. 操作系统
# 启动阶段
## 第一阶段 BIOS
实模式的内存布局: 在后边的章节介绍实模式
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/v2-d062c7668b08d68d752d498302208d05_1440w)

实模式下只有1MB空间内存地址为（00000h-fffffh）

图中的内容我们现在只需要关注红色框出来的地方，可以看到BIOS的入口地址处只有16B的空间，很显然，这一小块空间肯定存放的不是数据，只能是指令了，图中也写的很明显了
```
jmp f000:e05b
```
BIOS 也是程序，他的启动是靠硬件来完成的，开机一瞬即CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0. 然后 在调到0xf000:0xe05b BIOS开始工作。 接下来就对内存，显卡等外设进行检查，做好它的初始化工作之后就完成它的任务了，在最后的时候，BIOS会通过绝对远跳
```
jmp 0:0x7c00; 图片的第二个红圈
```

BIOS最后一项工作是校验启动盘中位于0盘0道1扇区的内容。

## 第二阶段 MBR

控制权转交给排在第一位的储存设备。

这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

"主引导记录"有且只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录由三个部分组成：

1. 第1-446字节：调用操作系统的机器码。
2. 第447-510字节：分区表（Partition table）
3. 第511-512字节：主引导记录签名（0x55和0xAA）

## 第三阶段 硬盘启动
计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

## 第四阶段 操作系统 
控制权转交给操作系统后，操作系统的内核首先被载入内存

# 实验 在屏幕上打印 ”1 MER“

我们的实验只经历了第一 二 阶段。

### 编写mbr文件
```
;主引导程序
;mbr.S
;------------------------------------------------------------
SECTION MBR vstart=0x7c00 ;把地址编译为0x7c00 SECTION 伪指令
   mov ax,cs
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00

; 清屏利用0x06号功能，上卷全部行，则可清屏
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入
;AH 功能号= 0x06
;AL = 上卷行数(如果为零,表示全部)
;BH = 上卷行属性
;(CL,CH) =窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角(X,Y)位置
;无返回值
   mov     ax, 0x600
   mov     bx, 0x700
   mov     cx, 0        ; 左上角: (0, 0)
   mov     dx, 0x184f	; 右下角: (80,25),
			            ; 80个字符 25行
			            ; 从下标0开始,所以0x18=24,0x4f=79
   int     0x10         ; int 0x10

;;;;;;;;;   下面这三行获取光标位置    ;;;;;;;;;
;.get_cursor获取当前光标位置，在光标位置打印字符
   mov ah, 3		    ; 3号子功能获取当前光标位置，
   mov bh, 0		    ; bh寄存器存储的是获取光标的页数

   int 0x10		        ; 输出: ch=光标开始,cl=光标结束
			            ; dh=光标所在行号dl=光标所在列号

;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

;;;;;;;;;     打印字符    ;;;;;;;;;;;
   ;int 10 调用13号子功能
   mov ax, message
   mov bp, ax		; es:bp 为首地址, es此时和cs一致
			        ; 开头已经初始化了sreg 初始化

   ; 光标位置要用到dx寄存器中的内容，cx中的光标长度可以忽略
   mov cx, 5		; cx为串长度，不包括结束符0的字符个数
   mov ax, 0x1301	;子功能号13是显示字符和属性，要存入ah寄存器
			        ; al设置写字符方式al=01 显示字符串 光标跟随移动
   mov bx, 0x2		; bh存储要显示的页号，此处是第0页
			        ;bl中是字符属性(bl = 02h)
   int 0x10		    ; ִ执行BIOS 0x10 中断
;;;;;;;;;      打印字符结束	 ;;;;;;;;;;;;;;;

   jmp $		    ; 使程序悬停在此处

   message db "1 MBR"
   times 510-($-$$) db 0 ;;为了是程序凑够510 字节
   db 0x55,0xaa
```
### 编译和观察文件
使用nasm 进行编译
```
nasm -I include/ -o mbr.bin mbr.S 
```
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211012160800.jpg) 查看一下确实是512字节

下一步将mbr.bin 写入0盘0道1扇区
```
# bs指定大小 count是1扇区
# of 就是hd60M.img 绝对地址
dd if=./mbr.bin of=/Users/isam2016/opt/bochs/hd60M.img bs=512 count=1  conv=notrunc
```
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211012161357.jpg)

### bochs运行

1. 运行 `bochs` 
2. 6
3. c ;c是开始执行 n是单步执行  
   
如果发生 `>>PANIC<< ata0-0: could not open hard drive image file 'hd60M.img'` 第一步请执行 `bochs -f  bochsrc.disk`

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211012165002.jpg)

我们观察一下debug

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211012170032.jpg)

$,$$ 是标号， 之前我们在汇编接触过 `mov cx,offset setscreen_end -  setscreen` 为了计算字节数

ss 代表 SECTION的地址

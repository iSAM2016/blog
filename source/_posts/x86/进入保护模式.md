---
title: 进入保护模式
date: 2021-10-14 17:25:54
tags:
categories:
---
> 真象还原-4.3
# 全局描述符

我们知道，为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。

这种情况好有一比。就像是开公司做生意，在实模式下，开公司不需要登记，卖什么都没有人管，随时都可以开张。但在保护模式下就不行了，开公司之前必须先登记，登记的信息包括住址（段的起始地址）、经营项目（段的界限等各种访问属性）。这样，每当你做的买卖和项目不符时，就会被阻止。对段的访问也是一样，当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断

可以看到，我们是需要很多段的。

和一个段有关的信息需要 8 个字节来描述，所以称为*段描述符（Segment Descriptor）*，每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的
描述符都是挨在一起，集中存放的，这就构成一个描述符表。

最主要的描述符表是*全局描述符表（Global Descriptor Table， GDT）(64KB)*，所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。 


理论上，全局描述符表可以位于内存中的任何地方。但是，如图 11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义 GDT。但是，由于在实模式下只能访问 1MB 的内存，故 GDT 通常都定义在 1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义 GDT。

![](20211015100004.jpg)

为什么将该表称为“全局”描述符表？全局体现在多个程序都可以在里面定义自己的段描述符，是公用的。全局描述符表位于内存中， 需要用专门的寄存器指向它后， CPU 才知道它在哪里。 这个专门的寄存器便是 GDTR，如上图的指向关系

# 段描述符

每个段是需要进行登记管理的。需要一个记录本进行记录。段描述符是 8 字节大小，共计8*8=64连续的的位
![](20211015095342.jpg)

各个字段的含义不在单独介绍。

段描述和内存质检的关系

![](20211015111206.jpg)

保护模式下地址总线宽度是 32 位，段基址需要用 32 位地址来表示。
<!-- TODO:偏移值 向上向下-->

# 选择子

回顾一下：
*在 32 位模式下，传统的段寄存器，如 CS、 SS、 DS、 ES，保存的不再是 16位段基地址，而是段的选择子，即，用于选择所要访问的段，因此，严格地说，它的新名字叫做段选择器。除了段选择器之外，每个段寄存器还包括一个 64 位的不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。*

![](20211015110222.jpg)

也很好理解，每个段都有一个专有描述符，当然要把段的信息全部放进去。

那么段选择器就空了，放的就是selector,选择子。

选择子是个索引值，此索引值在段描述符表中索引相应的段描述符，这样，便在段描述符
中得到了内存段的起始地址和段界限值等相关信息

选择子的结构
![](20211015111323.jpg)

由于段寄存器是 16 位，所以选择子也是 16 位

* RPL，即请求特权级，可以表示 0、 1、 2、 3 四种特权级。
* TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。 TI为 0 表示在 GDT 中索引描述符， TI 为 1 表示在 LDT 中索引描述符。
* 选择子的高 13 位，即第 3～15 位是描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。

由于选择子的索引值部分是 13 位，即 2 的 13 次方是 8192，故最多可以索引 8192 个段，这和 GDT中最多定义 8192 个描述符是吻合的。

选择子的作用主要是确定段描述符，确定描述符的目的，一是为了特权级、界限等安全考虑，最主要
的还是要确定段的基地址.

例如选择子是 0x8，将其加载到 ds 寄存器后，访问 ds： 0x9 这样的内存，其过程是： 0x8 的低 2 位是RPL，其值为 00。第 2 是 TI，其值 0，表示是在 GDT 中索引段描述符。用 0x8 的高 13 位 0x1 在 GDT 中索引，也就是 GDT 中的第 1 个段描述符（GDT 中第 0 个段描述符不可用）。假设第 1 个段描述符中的 3个段基址部分， 其值为 0x1234。CPU 将 0x1234 作为段基址， 与段内偏移地址 0x9 相加， 0x1234+0x9=0x123d。

大概的关系是 
![](20211015132137.jpg)

在保护模式下，由于已经是32位地址线和32位寄存器，不在需要经段基值乘以16在于段内偏移地址相加

值得注意的是上面括号中提到了 GDT 中的第 0 个段描述符是不可用的，

# lgdt
进入保护模式需要有 GDT，但进入保护模式后，还可以再重新换个 GDT 加载。在保护模式下重新换个 GDT 的原因是实模式下只能访问低端 1MB 空间，所以 GDT 只能位于 1MB 之内。

根据操作系统的实际情况，有可能需要把 GDT 放在其他的内存位置，所以在进入保护模式后，访问的内存空间突破了 1MB，可以将 GDT 放在合适的位置后再重新加载进来。

如图 11-1 所示，为了跟踪全局描述符表，处理器内部有一个 48 位的寄存器，称为*全局描述符表寄存器（GDTR）*。

![](20211015094856.jpg)

这 48 位内存数据划分为两部分
* 前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于GDT 的字节大小减 1。
* 后 32 位是 GDT 的起始地址。
  
由于 GDT 的大小是 16 位二进制，其表示的范围是 2的16次方等于65536字节(64KB)。每个描述符大小是8字节故， GDT中最多可容纳的描述符数量是65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

也就是说GTD 限制了段的个数

lgdt 的指令格式是： `lgdt48 位内存数据`; 前16+后32位 

<!--  TODO: 加载GDRT -->

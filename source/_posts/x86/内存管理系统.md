---
title: 内存管理系统
date: 2021-12-20 08:31:17
tags:
categories:
- 操作系统
---
# makefile

到目前为止，每次编译需要用 4 次 gcc，两次 nasm，和 ld 链接，操作十分麻烦，通过makefile可以简化这一块的操作。

makefile 文件是make 程序的搭档，这两主要作用是：发现某个文件更新后，只编译该文件和受该文件影响的相关文件，其他不受影响的文件不重新编译，从而提高了编译效率。

make 命令和 makefile 文件，它们之间关系类似脚本解析器和脚本语言文件，make程序是文件 makefile 的解析器，它定义了各种关键字、语法结构、函数、变量，甚至可以用 include 关键字包含其他 makefile。之后由 make 程序解析 makefile 中的内容，从而产生出不同的行为。

makefile 基本语法
```
目标文件:依赖文件 
[Tab]命令
```

makefile 基本语法包括三部分，这三部分加在一起称为一组*规则*
* 目标文件:是指此规则中想要生成的文件，可以是.o 结尾的目标文件，也可以是可执行文件，也可以是个伪目标。 
* 依赖文件:是指要生成此规则中的目标文件，需要哪些文件。通常依赖文件不是 1 个，所以此处是个依赖文件的列表。
* 命令:是指此规则中要执行的动作，这些动作是指各种 shell 命令。命令可以有多个，但一个命令要单独占用一行，在行首必须以 Tab 开头。这是 make 规定的用法，这样 make 在解析到以 Tab 开头的行时便知道这是要执行的命令。

```makefile
1:2
	echo "makefile test ok"
```
## 伪目标

当规则中不存在依赖文件时，这个目标文件名就称为—伪目标.当然也不产生真实的目标文件，所以伪目标也变成了命令

```makefile
all:
	@echo "makefile test ok"
```
执行 `make all 或make`.
其他的一些伪目标：
![](WX20211220-153917@2x.png)
![](20211220155224.jpg)

使用makefile 编译c语言文件。 递归推到目标。在makefile 中的目标，是以递归的方式逐层向上查找目标的，就好像是从迷宫的出口往回找来时的路一样， 由果寻因，逐个向上推导。

test1.c 
```c
void my_print();
void main()
{
    my_print("hello,world\n");
}
```

test2.c
```c
#include <stdio.h>
void my_print(char *str)
{
    printf(str);
}
```
```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
test.bin:test1.o test2.o
	gcc -o test.bin test1.o test2.o
all:test.bin
	@echo "compile done"
```
最后执行`make all`
```sh
isam2016@ubuntu:~/os$ make all
gcc -c -o test1.o test1.c
gcc -o test.bin test1.o test2.o
compile done
isam2016@ubuntu:~/os$ ls
1  2  makefile  test1.c  test1.o  test2.c  test2.o  test.bin
isam2016@ubuntu:~/os$ ./test.bin 
hello,world
```
我们看到生成 test.bin

## 自定义变量与系统变量
变量定义的格式:变量名=值（字符串） ，多个值之间用空格分开。值仅支持字符串类型，即使是数字也被当作字符串来处理。

变量引用的格式：$(变量名)。这样，每次引用变量时，变量名就会被其值（字符串）替换。

改写以上的makefile
```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o test.bin $(objfiles)
all:test.bin
	@echo "compile done"
```
执行文件如下：

```shell
isam2016@ubuntu:~/os$ make all
gcc -c -o test1.o test1.c
gcc -c -o test2.o test2.c
gcc -o test.bin test1.o test2.o
compile done
isam2016@ubuntu:~/os$ ./test.bin 
hello,world

```
除了用户自定义的变量外，make 还自行定义了一些系统级的变量，按其用途可分为命令相关的变量及参数相关的变量。
![](20211220170540.jpg)

## 自动变化量和模式规则
make 还支持一种自动化变量，此变量代表一组文件名，无论是目标文件名，还是依赖文件名，此变量值的范围属于这组文件名集合，
 
`$@`表示规则中的目标文件名集合，如果存在多个目标文件，$@则表示其中每一个文件名。

`$<`表示规则中依赖文件中的第 1 个文件。

`$^`表示规则中所有依赖文件的集合，如果集合中有重复的文件，$^会自动去重

`$?`，表示规则中，所有比目标文件 mtime 更新的依赖文件集合。

```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o $@ $^
all:test.bin
	@echo "compile done is"
```

执行make all
```shell
root@ubuntu:/home# make all
makefile:4: warning: overriding recipe for target 'test2.o'
makefile:2: warning: ignoring old recipe for target 'test2.o'
gcc -c -o test1.o test1.c
gcc -c -o test2.o test2.c
gcc -o test.bin test1.o test2.o
compile done is
root@ubuntu:/home# ./test.bin 
hello,world
```

1. %用来匹配任意多个非空字符。比如%.o 代表所有以.o 为结尾的文件，
2. g%s.o 是以字符 g 开头的所有以.o 为结尾的文件，make 会拿这个字符串模式去文件系统上查找文件，默认为当前路径下。

当%用在依赖文件中时，其所匹配的文件名要以目标文件为准。拿%.o:%.c 为例，假如用%.o 匹配到了目标文件 a.o 和 b.o，那么依赖文件中的%.c 将分别匹配到 a.c 和 b.c。

继续修改makefile
```makefile
%.o:%.c
	gcc -c -o $@ $^
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o $@ $^
all:test.bin
	@echo "compile done"
```

## 实现assert 断言
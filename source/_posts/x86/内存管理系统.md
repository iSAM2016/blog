---
title: 真象还原-内存管理系统
date: 2021-12-20 08:31:17
tags:
categories:
- 操作系统
---
# makefile

到目前为止，每次编译需要用 4 次 gcc，两次 nasm，和 ld 链接，操作十分麻烦，通过makefile可以简化这一块的操作。

makefile 文件是make 程序的搭档，这两主要作用是：发现某个文件更新后，只编译该文件和受该文件影响的相关文件，其他不受影响的文件不重新编译，从而提高了编译效率。

make 命令和 makefile 文件，它们之间关系类似脚本解析器和脚本语言文件，make程序是文件 makefile 的解析器，它定义了各种关键字、语法结构、函数、变量，甚至可以用 include 关键字包含其他 makefile。之后由 make 程序解析 makefile 中的内容，从而产生出不同的行为。

makefile 基本语法
```
目标文件:依赖文件 
[Tab]命令
```

makefile 基本语法包括三部分，这三部分加在一起称为一组*规则*
* 目标文件:是指此规则中想要生成的文件，可以是.o 结尾的目标文件，也可以是可执行文件，也可以是个伪目标。 
* 依赖文件:是指要生成此规则中的目标文件，需要哪些文件。通常依赖文件不是 1 个，所以此处是个依赖文件的列表。
* 命令:是指此规则中要执行的动作，这些动作是指各种 shell 命令。命令可以有多个，但一个命令要单独占用一行，在行首必须以 Tab 开头。这是 make 规定的用法，这样 make 在解析到以 Tab 开头的行时便知道这是要执行的命令。

```makefile
1:2
	echo "makefile test ok"
```
## 伪目标

当规则中不存在依赖文件时，这个目标文件名就称为—伪目标.当然也不产生真实的目标文件，所以伪目标也变成了命令

```makefile
all:
	@echo "makefile test ok"
```
执行 `make all 或make`.
其他的一些伪目标：
![](WX20211220-153917@2x.png)
![](20211220155224.jpg)

使用makefile 编译c语言文件。 递归推到目标。在makefile 中的目标，是以递归的方式逐层向上查找目标的，就好像是从迷宫的出口往回找来时的路一样， 由果寻因，逐个向上推导。

test1.c 
```c
void my_print();
void main()
{
    my_print("hello,world\n");
}
```

test2.c
```c
#include <stdio.h>
void my_print(char *str)
{
    printf(str);
}
```
```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
test.bin:test1.o test2.o
	gcc -o test.bin test1.o test2.o
all:test.bin
	@echo "compile done"
```
最后执行`make all`
```sh
isam2016@ubuntu:~/os$ make all
gcc -c -o test1.o test1.c
gcc -o test.bin test1.o test2.o
compile done
isam2016@ubuntu:~/os$ ls
1  2  makefile  test1.c  test1.o  test2.c  test2.o  test.bin
isam2016@ubuntu:~/os$ ./test.bin 
hello,world
```
我们看到生成 test.bin

## 自定义变量与系统变量
变量定义的格式:变量名=值（字符串） ，多个值之间用空格分开。值仅支持字符串类型，即使是数字也被当作字符串来处理。

变量引用的格式：$(变量名)。这样，每次引用变量时，变量名就会被其值（字符串）替换。

改写以上的makefile
```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o test.bin $(objfiles)
all:test.bin
	@echo "compile done"
```
执行文件如下：

```shell
isam2016@ubuntu:~/os$ make all
gcc -c -o test1.o test1.c
gcc -c -o test2.o test2.c
gcc -o test.bin test1.o test2.o
compile done
isam2016@ubuntu:~/os$ ./test.bin 
hello,world

```
除了用户自定义的变量外，make 还自行定义了一些系统级的变量，按其用途可分为命令相关的变量及参数相关的变量。
![](20211220170540.jpg)

## 自动变化量和模式规则
make 还支持一种自动化变量，此变量代表一组文件名，无论是目标文件名，还是依赖文件名，此变量值的范围属于这组文件名集合，
 
`$@`表示规则中的目标文件名集合，如果存在多个目标文件，$@则表示其中每一个文件名。

`$<`表示规则中依赖文件中的第 1 个文件。

`$^`表示规则中所有依赖文件的集合，如果集合中有重复的文件，$^会自动去重

`$?`，表示规则中，所有比目标文件 mtime 更新的依赖文件集合。

```makefile
test2.o:test2.c
	gcc -c -o test2.o test2.c
test1.o:test1.c
	gcc -c -o test1.o test1.c
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o $@ $^
all:test.bin
	@echo "compile done is"
```

执行make all
```shell
root@ubuntu:/home# make all
makefile:4: warning: overriding recipe for target 'test2.o'
makefile:2: warning: ignoring old recipe for target 'test2.o'
gcc -c -o test1.o test1.c
gcc -c -o test2.o test2.c
gcc -o test.bin test1.o test2.o
compile done is
root@ubuntu:/home# ./test.bin 
hello,world
```

1. %用来匹配任意多个非空字符。比如%.o 代表所有以.o 为结尾的文件，
2. g%s.o 是以字符 g 开头的所有以.o 为结尾的文件，make 会拿这个字符串模式去文件系统上查找文件，默认为当前路径下。

当%用在依赖文件中时，其所匹配的文件名要以目标文件为准。拿%.o:%.c 为例，假如用%.o 匹配到了目标文件 a.o 和 b.o，那么依赖文件中的%.c 将分别匹配到 a.c 和 b.c。

继续修改makefile
```makefile
%.o:%.c
	gcc -c -o $@ $^
objfiles = test1.o test2.o
test.bin:$(objfiles)
	gcc -o $@ $^
all:test.bin
	@echo "compile done"
```

## 实现assert 断言
ASSERT 是用来辅助程序调试的，所以通常是用在开发阶段。如果程序中的某些地方会莫名其妙地出错，而我们又无法短时间内将其排查出来，这时我们可以在程序中安排个“哨兵” ，这个哨兵就是 ASSERT。

我们把程序该有的条件状态传给它，让它帮咱们监督此条件，一旦条件不符合就会报错并将程序挂起。 ˿
我们在 C 语言中这样使用 

`ASSERT：条件表达式`

在 C 语言中 ASSERT 是用宏来定义的，其原理是判断传给 ASSERT 的表达式是否成立，若表达式成立则什么都不做

`lib/string.h`
```c

#ifndef __LIB_STRING_H
#define __LIB_STRING_H

#include "stdint.h"
#define NULL 0
void memset(void *dst_, uint8_t value, uint32_t size);
void memcpy(void *dst_, const void *src_, uint32_t size);
int memcmp(const void *a_, const void *b_, uint32_t size);
char *strcpy(char *dst_, const char *src_);
uint32_t strlen(const char *str);
int8_t strcmp(const char *a, const char *b);
char *strchr(const char *str, const uint8_t ch);
char *strrchr(const char *str, const uint8_t ch);
char *strcat(char *dst_, const char *src_);
uint32_t strchrs(const char *str, uint8_t ch);
#endif

```
# 位图bitmap

位图，也就是 bitmap，广泛用于资源管理，是一种管理资源的方式、手段。 “资源”包括很多，比如内存或硬盘，对于此类大容量资源的管理一般都会采用位图的方式。 

位图包含两个概念：位和图。

位图就是用字节中的 1 位来映射其他单位大小的资源，按位与资源之间是一对一的对应关系。

计算机中最小的数据单位是位，于是，用一组二进制位串来管理其他单位大小的资源是很自然的事， 这组二进制位中的每一位与其他资源中的数据单位都是一对一的关系，这实际就成了一种映射，即 map， 于是这组二进制位就有了更恰当的名字—位图。

既然位图本质上就是一串二进制位，那对于它的实现，用字节型数组还是比较方便的，数组中的每一个元素都是一字节，每 1 字节含有 8 位，因此位图的 1 字节对等表示 8 个资源单位。

位图中的每一位有两种状态，即 0 和 1，所以一般情况下，位图所管理的资源被我们人工划分为两种状态。位图用 0 和 1 这两种状态反应实际所管理资源的状态，比如位图中的 0 表示该资源未占用，位图中的 1 表示该资源已占用。

用位图来管理内存，位图中的每一位都将表示实际物理内存中的 4KB，也就是一页， 即位图中的一位对应物理内存中的一页，如果某位为 0，表示该位对应的页未分配，可以使用，反之如果某位为 1，表示该位对应的页已经被分配出去了， 在将该页回收之前不可再分配。

<!--  图片-->
其中， “管理结构的单位大小”是指位图中的 1 位，也就是如图 位图框中的“黑点” ， “资源自己的单位大小”就是指以 4KB 为单位大小的内存，也就是图中每一个 4KB 的小格子。注意，内存本身最小可寻址单位是字节，4KB 是人为划分的内存单位，内存中可没有一个个 4KB 大小的“格子” 。之所以这样做，原因就像上面所说的，将所管理资源的单位调整到最大。

# 位图的实现
---
title: 内存管理系统2
date: 2022-01-21 10:06:08
tags:
categories:
- 操作系统
---
需要明确的是我们使用的borchs 的虚拟机的内存是32M. 在配置文件中已经说明。
# 内存管理系统

用户程序所占用的内存空间是由操作系统分配的，我们要解决内存是如何分配的并且该给用户进程分配多少字节

在保护模式下，程序地址变成了虚拟地址，虚拟地址对应的物理地址是由分页机制做的映射。因此，在分页机制下有了虚拟、物理这两种地址，操作系统有责任把这两种地址分别管理，并通过页表将这两类地址关联。

内存地址池的概念是将可用的内存地址集中放到一个“池子”中，需要的时候直接从里面取出，用完后再放回去。由于在分页机制下有了虚拟地址和物理地址，为了有效地管理它们，我们需要创建虚拟内存地址池和物理内存地址池。

## 规划物理内存池

内核和用户进程肯定都要运行在物理内存之中， 将物理内存划分成两部分， 一部分只用来运行内核， 另一部分只用来运行用户进程， 将内存规划出不同的部分，专项专用。

操作系统为了能够正常运行，不能用户进程申请多少内存就分配多少，必须得给自己预留出足够的内存才行，否则有可能会出现因为物理内存不足，导致内核自己都无法正常运行、自身难保的现象

内存池中的内存也得按单位大小来获取，这个单位大小是 4KB，称为页，故，内存池中管理的是一个个大小为 4KB 的内存块，从内存池中获取的内存大小至少为 4KB 或者为 4KB 的倍数

为了方便实现，咱们把这两个内存池的大小设为一致，即各占一半的物理内存，
![](20220121104531.jpg)

当用户内存池中的内存都被用户进程耗尽时，不再向内核内存池申请，而是返回信息“内存不足” ，拒绝请求。

## 虚拟内存池

回顾一下虚拟地址内存图。
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20211021172045.jpg)

程序（进程、内核线程）在运行过程中也有申请内存的需求，这种动态申请内存一般是指在堆中申请内存， 操作系统接受申请后，为进程或内核自己在堆中选择一空闲的虚拟地址，并且找个空闲的物理地址作为此虚拟地址的映射，之后把这个虚拟地址返回给程序。

对于所有任务（包括用户进程、内核）来说，它们都有各自 4GB 的虚拟地址空间，因此需要为所有任务都维护它们自己的虚拟地址池，即一个任务一个。

内核为完成某项工作， 也需要申请内存， 我们让内核也通过内存管理系统申请内存，为此，它也要有个虚拟地址池，当它申请内存时，从内核自己的虚拟地址池中分配虚拟地址，再从内核物理内存池（内核专用）中分配物理内存，然后在内核自己的页表将这两种地址建立好映射关系。

对用户进程来说，它向内存管理系统，即操作系统，申请内存时，操作系统先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池（所有用户进程共享）中分配空闲的物理内存，然后在该用户进程自己的页表将这两种地址建立好映射关系。

为方便管理，虚拟地址池中的地址单位也是 4KB，这样虚拟地址便于和物理地址做完整页的映射。 

当前虚拟机配置了32MB 的物理内存。 共计32\*1024KB。则需要 32\*1024KB/4KB =8*1024个地址单位 。回顾一下 ”位图与内存“ 图片。 也就是需要 8\*1024 个比特。也就是需要 8\*1024/8=1024个字节

![](20220121133530.jpg)

管理虚拟内存。内存管理代码 如下:
`kernel/memory.h`
```h
//  虚拟地址结构
#ifndef __KERNEL_MEMORY_H
#define __KERNEL_MEMORY_H
#include "stdint.h”
#include "bitmap.h"
// 虚拟地址池 ，用于虚拟地址管理
struct virtual_addr
{
    struct bitmap vaddr_bitmap; // 虚拟地址用到的位图结构
    uint32_t vaddr_start;       // 虚拟地址起始地址
};

extern struct pool kernel_pool, user_pool;
void mem_init(void);
#endif
```

* vaddr_bitmap

它的类型是位图结构体，用来以页为单位管理虚拟地址的分配情况

虚拟地址也要分配.进程在运行时可以动态从堆中申请内存，系统为其分配的虚拟地址也属于此进程的虚拟地址空间，也必须要保证虚拟地址的唯一性，所以，用位图来记录虚拟地址的分配情况。


* vaddr_start 

用来记录虚拟地址的起始值，咱们将来在分配虚拟地址时，将以这个地址为起始分配

`kernel/memory.c`
<!-- TODO: 位图 和 虚拟内存的关系 -->
多参考手绘图。 先计一下数量

当前虚拟机配置了32MB 的物理内存，这32MB 物理内存需要1024 字节的位图，(已经在上面列出了公式)也就是仅占四分之一页， 故一页大小的位图可管理 128MB 的内存。对于目前的 32MB 内存来说，用一页内存来存储位图还浪费，打算支持 4 页内存的位图，即最大可管理 512MB 的物理内存。

```

```



物理地址 0x100000～0x101fff，是我们已经在 loader.S 中定义好的页目录及页表(请看手绘内存图)因此将来的内核虚拟地址 0xc0100000～0xc0101fff 并不映射到这两个物理地址，必须要绕过它们
---
title: 汇编学习-第十三章
date: 2021-09-29 11:04:52
tags:
categories:
- 汇编
---

# int指令
中断信息来自cpu的内部和外部。

int指令的格式为：int n ，n为中断类型码，它的功能是引发中断过程。

CPU执行int n指令，相当于引发一个n号中断的中断过程。 
1. 取出中断类型编码n
2. 标志寄存器入栈IF=0,TF=0
3. cs，ip入栈
4. (ip)=(n*4),(cs)=(n * 4 + 2)

在程序中使用int指令调用任何一个中断的中断处理程序(中断例程)

# 编写供应用程序调用的中断例程
## 求一word型数据的平方
```
;----------------------
;p13-sqr.asm
;安装中断7ch的中断例程，并计算word类型数据平方
;参数：ax
;返回： dx，ax中分别存放高16位和低16位
;----------------------
assume cs:code

code segment
    start:
        call copy_new_int7ch
        call set_new_int7ch
       
        mov ax,3456
        int 7ch
        
        mov ax,4c00h
        int 21h
    sqr:  
		mul ax
		iret  ;CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈
		      ;在执行完中断例程后，应该用iret 指令恢复int 7ch执行前的标志寄存器和CS、IP的
    sqr_end: nop                                            
    set_new_int7ch:
        mov ax,0
        mov es,ax
        
        mov word ptr es:[7ch*4], 200h
        mov word ptr es:[7ch*4+2], 0

        ret
    copy_new_int7ch:
        mov ax,cs
        mov ds,ax
        mov si,offset sqr					;设置ds:si指向源地址

        mov ax,0
        mov es,ax
        mov di,200h							;设置es:di指向目的地址
        
        mov cx,offset sqr_end -  sqr	;设置cx为传输长度
        cld									;设置传输方向为正
        rep movsb

        ret
        
code ends
end start
```
运行结果
![](20211007221713.png)

3456 * 3456 = b64000h

## 检测点13.1
1. 在上面内容中，我们用7cH中断例程实现loop功能，则上面的7cH中断例程所能进行的最大转移位移是多少？

如果从例程中bx变量来说，先搞定bx存储二进制补码数据的表示范围。对于16位来说它表示的范围是（-32768~32767）。

我们知道在内存中是按照计算机补码方式存储的，最小的负数（也就是绝对值最大的数）是8000H也就是-32768，那么它最大的转移位移是32768。

2. 用7ch中断例程完成jmp near ptr s指令功能，用bx向中断例程传送转移位移。

```
assume cs:code
code segment
    start:      
        ;7cH中断例程的安装程序
         mov ax, cs
         mov ds, ax
         mov si, offset lp   ;将ds:si指向源地址（captial的机器码）
         mov ax, 0000H
         mov es, ax
         mov di, 200H        ;将es:di指向目的地址（0:200H向量表中）
         mov cx, offset lpend - offset lp    ;设置传输长度
         cld             ;传输方向为正
         rep movsb       ;字节传输

         ;设置中断向量表，使7cH条目中断向量指向0000:200H
         mov ax, 0000H
         mov es, ax
         mov word ptr es:[7cH*4], 200H
         mov word ptr es:[7cH*4+2], 0000H

         mov ax, 4c00H
         int 21H
;-------
;装载的例程：7cH
;功能：int 7cH实现和jmp near ptr s指令相同的功能
;入口参数：bx相对地址偏移量
;返回值：无
;-------   

    lp:    
        push bp         ;将bp这个ss栈的偏址保存
        mov bp, sp      ;将当前栈顶指针值送入到bp
        add [bp+2], bx  ;修改ss栈中的从栈顶向下第2个单元的值
    lpret: 
        pop bp          ;恢复bp值
        iret            ;返回到调用处。
    lpend:  
        nop             ;代码段结尾，便于计算7cH例程的长度。   

code ends
end start
```

# BIOS和DOS所提供的中断例
在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统）

BIOS中主要包含以下几部分内容

* 硬件系统的检测和初始化程序；
* 外部中断和内部中断的中断例程；
* 用于对硬件设备进行I/O操作的中断例程；
* 其他和硬件系统相关的中断例程。

程序员在编程的时候，可以用int 指令直接调用BIOS和DOS系统提供的中断例程，来完成某些工作。
和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。

## BIOS和DOS中断例程的安装过程
BIOS和DOS提供的中断例程是如何安装到内存中的呢？

1. 开机后，CPU一加电，初始化（CS）= 0FFFFH，（IP）= 0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
2. 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。
注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。
3. 硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。
4. DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

## BIOS中断例程应用
一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。

BIOS和DOS提供的中断例程，都用 ah 来传递内部子程序的编号。
<!-- TODO: 在Mac 下没有成功呢 -->
```
;p13-6.asm
assume cs:code 

code segment
    ;int 10h中断例程的"设置光标位置"功能
    mov ah, 2  ;设置光标调用第10h号中断例程的2号子程序，功能为设置光标位置(可以提供光标所在的行号、列号和页号作为参数)

    ;设置光标到第0页，第5行，第12列
    mov bh, 0;
    mov dh, 5; dh中放行号
    mov dl, 12; dl中放列号
    int 10h

    ;int10h中断例程的"在光标位置显示字符"功能。
    mov ah,9 ;调用第10h号中断例程的9号子程序，功能为在光标位置显示字符
    ;提供要显示的字符、颜色属性、页号、字符重复个数作为参数
    mov al,'a'  ;字符
    mov bl,11001010b  ;颜色属性
    mov bh,0  ;第0页
    mov cx,3  ;字符重复个数
    int 10h

code ends 
end
```

bh中页号的含义：内存地址空间中，B8000H~BFFFFH共32kB的空间，为80*25彩色字符模式的显示缓冲区。
一屏的内容在显示缓冲区中共占4000个字节。显示缓冲区分为8页，每页4KB（约4000B），显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。

## DOS中断例程应用
int 21h中断例程是DOS提供的中断例程，4ch号功能，即程序返回功能
```
;p13-7.asm
assume cs:code 
 
data segment 
	db	'Welcome to masm',  '$'     ;“$”本身并不显示，只起到边界的作用
data ends 

code segment
start:	mov ah, 2 ;10号中断设置光标位置功能
		mov bh, 0 ;第0页
		mov dh, 5；dh中放行号
		mov dl, 12 ;dl中放列号
		int 10h 
		
		mov ax, data 
		mov ds, ax 
		mov dx, 0 ;ds:dx指向字符串的首地址data:0  （参数）
		mov ah, 9 ;调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数
		int 21h 
		
		mov ax, 4c00h ;21号中断程序返回功能
		int 21h 
code ends
end start

```
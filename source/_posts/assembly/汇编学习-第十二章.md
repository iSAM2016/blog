---
title: 汇编学习-第十二章
date: 2021-09-23 17:19:57
tags:
categories:
- 汇编
---

# 内中断的产生
任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。

中断信息可以来自CPU的内部和外部（内中断，外中断）

内中断：当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部

8086CPU的内中断（下面四种情况将产生中断信息）

除法错误，比如，执行div指令产生的除法溢出；
* 单步执行；
* 执行 into指令；
* 执行 int指令。
中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源（中断源）

上述的4种中断源，在8086CPU中的中断类型码如下。

* 除法错误：0 
* 单步执行：1
* 执行into指令：4
* 执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。

# 中断处理程序
*中断处理程序*

用来处理中断信息的程序被称为中断处理程序。

根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序。

*中断向量表*

中断向量就是中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表

CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20210928173450.jpg)

* 中断向量表在内存中放置，从内0000:0000 到 0000:03ff的1024个单元
* 在中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址。 这个入口地址包括段地址和偏移地址。 一个表项占用两个**字**。高地址存放段地址，低地址存放偏移地址

# 检测12.1 

1. 判断入口地址

注意： 一项表项占用两个字，4个字节。
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20210928175459.png)

一项表项占用两个字，4个字节。

1. 通过以上的图解 不难发现
   1. 存储N号中断源对应的中断处理程序入口的*偏移地址*的内存单元的地址为： 4N
   2. 存储N号中断源对应的中断处理程序入口的*段地址*的内存单元的地址为：4N+2


补充： 8086系统把中断向量表中的中断明确分为3个部份：

1. 专用中断：类型号0~4（所以中断不是从1开始，而是0）
2. 系统备用中断：类型号5~31H
3. 用户中断：类型号32H~0FFH

# 中断过程

中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP。

cpu收到中断信息后，要对中断信息进行处理，首先将引发中断过程，硬件在完成中断过程后，CS:IP 将指向中断处理的入口，cpu开始执行中断处理程序 

中断的过程
* 取得中断类型码N；
* 标志寄存器入栈，因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中
* TF=0，IF=0 （为什么这样参考单步中断）
* push CS , push IP
* 读取IP 和cs（IP）=（N * 4），（CS）=（N * 4 + 2）

硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。

# iret指令
CPU随时都可能执行中断处理程序，中断处理程序必须一直存储在内存某段空间之中
而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。

中断处理程序的常规编写步骤：

* 保存用到的寄存器；
* 处理中断；
* 恢复用到的寄存器；
* 用iret指令返回。
  
iret 指令描述为：`pop IP pop CS popf`

# 4、除法错误中断的处理

```
;diverror.asm
assume cs:codesg
codesg segment
	begin:  
        mov ax, 1000h 
        mov bh, 1
        div bh ;除法溢出错误
codesg ends
end begin
```

![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20210929093950.jpg)

编程处理0号中断: 当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。
 
书中的12.7-12.10是程序分析，不在赘述

回顾movsb 功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减

代码总结如下
```
;sdo0.asm
assume cs:code
code segment
start:	
		mov ax, cs
		mov ds, ax
		mov si, offset do0		;设置ds:si指向源地址
		mov ax, 0
		mov es, ax
		mov di, 200h			;设置es:di指向目的地址0000:0200
		mov cx, offset do0end - offset do0		;设置cx为传输长度 编译时给出do0部分代码长度
		cld				        ;设置传输方向为正
		rep movsb ;将do0的代码送入0:200处
		
		mov ax, 0               ;设置中断向量表
		mov es, ax
		mov word ptr es:[0*4], 200h
		mov word ptr es:[0*4+2], 0

      	mov ax,4c00h
      	int 21h
;--------------------
;do0程序的主要任务是显示字符串
;参数无
;返回无
;--------------------
do0:	
    jmp short do0start 
    db "overflow!"

do0start:
    mov ax, cs
    mov ds, ax
    mov si, 202h			;设置ds:si指向字符串

    mov ax, 0b800h
    mov es, ax
    mov di, 12*160+36*2		;设置es:di指向显存空间的中间位置

    mov cx, 9				;设置cx为字符串长度
s:	mov al, [si]
    mov es:[di], al
    inc si
    add di, 1
    mov al, 02h             ;设置颜色
    mov es:[di], al        
    add di, 1
    loop s

    mov ax, 4c00h
    int 21h
do0end:	nop


code ends
end start


```
当执行完do0.exe 之后我们在执行diverror.exe 结果如下
![](https://isam2016hexo.oss-cn-hangzhou.aliyuncs.com/img/20210929103548.jpg)

# 单步中断
CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1

Debug是如何利用CPU所提供的单步中断的功能进行调试？如使用t命令查看寄存器状态

Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令

在使用t命令执行指令时，Debug将TF设置为1，在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。

在进入中断处理程序之前，设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断

# 试验12 编写0号中断的处理程序

请参考do0.asm
---
title: 汇编学习-第十章
date: 2021-09-17 15:08:46
categories:
- 汇编
---
> 此节重点记忆汇编指令，不必记忆公式

# ret 和 retf

call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。

ret指令用栈中的数据，修改IP的内容，从而实现近转移；

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

影响栈的元素（SS:SP）

CPU执行ret指令时，相当于进行： pop IP

* (IP) = ((ss) * 16 + (sp))
* (sp) = (sp) + 2

CPU执行retf指令时，相当于进行：pop IP, pop CS

* (IP) = ( (ss) * 16 + (sp))
* (sp) = (sp) + 2
* (CS) = ( (ss) * 16 + (sp))
* (sp) = (sp) + 2

```
;p10-1-1.asm
assume cs:code

stack segment
 db 16 dup(8)
stack ends

code segment
        mov ax,4c00H
        int 21h
    start:  
        mov ax,stack
        mov ss,ax   
        mov sp,16 ; 栈顶

        mov ax,0
        push ax ;sp=sp-2
        mov bx,0
        ret      ; (ip)= (ss * 16) + (sp) ss为stack 段地址  
                 ; sp 设置为为10H
                 ; push ax sp=sp-2(一个子为两个字节)  sp为EH
                 ; (IP) = ((ss) * 16 + (sp)) 获取栈的中ss:[14]的内容为零
                 ; (sp)=(sp)+2  sp 为10Hcd
code ends
end start
```
---

```
;p10-1-2.asm
assume cs:code

stack segment
 db 16 dup(8)
stack ends

code segment
        mov ax,4c00H
        int 21h
    start:  
        mov ax,stack
        mov ss,ax   
        mov sp,16 ; 栈顶

        mov ax,0
        push cs ;sp=sp-2
        push ax ;sp=sp-2
        mov bx,0
        retf     ; (ip)= (ss * 16) + (sp) ss为stack 段地址  
                 ; sp 设置为为10H
                 ; push cs sp=sp-2(一个字为两个字节)  sp为EH 
                 ; push ax sp=sp-2(一个子为两个字节)  sp为CH
                 ; (IP) = ((ss) * 16 + (sp)) 获取栈的中ss:[12]的内容为0
                 ; (sp)=(sp)+2  sp 为EH
                 ; (CS) = ( (ss) * 16 + (sp)) 获取cs的地址
                ; (sp) = (sp) + 2 为10H
code ends
end start
```

## 检测10.1 
补全程序，实现内存1000：0000 处开始执行指令
```
;p10-1.asm
assume cs:code

stack segment
 db 16 dup(8)
stack ends

code segment
        mov ax,4c00H
        int 21h
    start:  
        mov ax,stack
        mov ss,ax   
        mov sp,16 ; 栈顶

        mov ax,1000H;cs 地址先进入栈
        push ax ;sp=sp-2
        mov ax,0  ;ip地址后进入栈
        push ax
        retf     ; (ip)= (ss * 16) + (sp) ss为stack段地址  
                 ; sp 设置为为10H
                 ; push ax sp=sp-2(一个字为两个字节)  sp为EH  cs 地址先进入栈
                 ; push ax sp=sp-2(一个子为两个字节)  sp为CH  ip 地址后进入栈
                 ; (IP) = ((ss) * 16 + (sp)) 获取栈的中ss:[12]的内容为0
                 ; (sp)=(sp)+2  sp 为EH
                 ; (CS) = ( (ss) * 16 + (sp)) 获取cs的地址
                 ; (sp) = (sp) + 2 为10H
code ends
end start
```

![](20210917170814.jpg)


# call 指令
call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：

* （1）将当前的 IP 或 CS和IP 压入栈中；
* （2）转移（jmp）。

call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。

## 依据位移进行转移的call指令
`call 标号（将当前的IP压栈后，转移到标号处执行指令）`

cpu 执行此格式call指令时，进行的是如下操作： 

1. 
   * (sp)=(sp)-2
   * ((ss)*16+(sp))=(ip)
2. 
   * (ip)=(ip)+16位位移
  
* 16 位位移=标号处的地址-call指令后的第一个字节的地址
* 16位位移的范围为-32768-3276，用**补码**来表示
* 16位位移由编译程序在编译时算出

CPU执行此种格式的call指令时，相当于进行 

* `push IP` 
* `jmp near ptr 标号`

## 检测10.2
```
;p10-2.asm
assume cs:codesg
codesg segment
    start: 
            mov ax,0
            call s
            inc ax
        
        s: pop ax
            mov ax,4c00h
            int 21h
codesg ends
end start
```
![](20210918104757.jpg)

题目中给出了，机器码，我们可以数字节

* `mov ax,0` 三个字节，执行完，ip为3 cs:[3] 指向 `call s`
* `call s` 三个字节，执行完，ip 为6 
* 栈存储IP的值（push IP）存储6
* ip 指向一条语句cs:[7]
* 跳转到标号s， 并执行`pop ax`, 取出6 放到ax 为6

## 转移的目的地址在指令中的call指令
`call far ptr 标号` 实现的是段间转移

CPU执行此种格式的call指令时，相当于进行：
* `push CS`
* `push IP`
* `jmp far ptr 标号`

```
;p10-3.asm
;题目中给出 cs的初始值是 1000h
assume cs:codesg
codesg segment
    mov ax,4c00h
    int 21h
start: 
    mov ax,0
    call far ptr s  ;CS为1000h入栈，IP为8（数一下机器码），跳转到s
    inc ax          ; 不执行

s: 
    pop ax          ;ax=8, 取栈顶8
    add ax,ax       ;ax=16
    pop bx          ;bx=1000h
    add ax,bx       ;ax=1010h(16 为10H)
    mov bx,0
    push bx
    ret
codesg ends
end start
```
注意： 我的cs地址不是1000H

![](20210918112314.jpg)
```
;p10-3.asm 实验
assume cs:codesg
codesg segment
    mov ax,4c00h
    int 21h
start: 
    mov ax,0
    call far ptr s  ;CS为076AH ，IP为DH(8+5=13)，跳转到s
    inc ax          ; 不执行

s: 
    pop ax          ;ax=DH, 取栈顶13
    add ax,ax       ;ax=1AH （26）
    pop bx          ;bx=076AH
    add ax,bx       ;ax=0784h
    mov bx,0
    push bx
    ret
codesg ends
end start
```
![](20210918120341.jpg)


![](20210918120424.jpg)

## 转移地址在寄存器中的call指令
`call 16位寄存器`

CPU执行此种格式的call指令时，相当于进行：
* `push IP`
* `jmp 16位寄存器`

先回忆一下bp
```
mov ax, [bp]
mov ax, [bp+8]
mov ax, [bp+si]
mov ax, [bp+si+8]   ;以上段地址默认在ss中
```

sp的默认段是ss

```
;p10-4.asm 实验
assume cs:codesg
codesg segment
start: 
    mov ax,6    ;执行完后ip为3 
    call ax     ;执行完后ip为5 首先将IP压进栈中， jmp 6
    inc ax 
    
    mov bp,sp   ;跳转到这里 此处的含义 ((ss*16)+bp)=((ss*16)+sp)
    add ax,[bp] ;将（ax）= ((ss*16)+bp)(获取栈顶元素5) + (ax)(6)  ax为BH（11）
codesg ends
end start
```
![](20210918143648.jpg)

## 转移地址在内存call指令

`call word ptr 内存单元地址`

CPU执行此种格式的call指令时，相当于进行：

* `push IP`
* `jmp word ptr 内存单元地址`

```
mov sp, 10h         ;直接将10h赋值到sp
mov ax, 0123h
mov ds:[0], ax
call word ptr ds:[0] ;push IP 意味着sp=sp-2 变为了EH，ds:[0] 为0123h 指令跳转到0123h 即 (IP)=0123H
;执行后，(IP)=0123H，(sp)=0EH
```

`call dword ptr 内存单元地址`

CPU执行此种格式的call指令时，相当于进行：

* `push CS`
* `push IP`
* `jmp dword ptr 内存单元地址`

```
mov sp, 10h
mov ax, 0123h
mov ds:[0], ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
;执行后，（cs）=0 (IP)=0123H，(sp)=0EH
```

```
;检测10-5-1
assume cs:code
stack segment
    dw 8 dup (0);0-15 16个字节
stack ends

code segment
    start: 
        mov ax,stack
        mov ss,ax   ;将stack段地址放在 ss 中
        mov sp,16   ;设置sp为16 是10H 指向栈顶 栈的结构请看图，栈的存储位置是0-15 
        低16位为栈顶
        mov ds,ax   ;将stack段地址放在 ds 中
        mov ax,0    ;设置ax 为零
        call word ptr ds:[0EH]
        ; push IP  此时的cs:ip 指向的是第一个`inc c`, 将IP偏移数存储到栈顶的位置 此时 sp=sp-2  就是14（0EH）
        ; 地址跳转到ds:[0EH]  就是stack 栈顶,就是读取到，也就是从 inc ac 开始执行又跳了回来 
        ; 此时 ax=0

        inc ax
        inc ax
        inc ax
        ; ax=3
        mov ax,4c00H
        int 21H
code ends
end start
```

![](20210918163559.jpg)


这道题目得数字节数，重点是理解`call dword ptr ss:[0]` 可以直接debug 进行观察

```
;检测10-5-2
assume cs:code
data segment
    dw 8 dup (0); 初始8个字，16个字节空间
data ends
code segment
    start: 
        mov ax,data
        mov ss,ax
        mov sp,16                    ;初始化栈顶
        mov word ptr ss:[0],offset s ;(ss:[0])=001ah(到标号s共计26个字节)
        mov ss:[2],cs                ;(ss:[2])=cs
        call dword ptr ss:[0]        ;cs 入栈，IP入栈 跳转到cs:0001h，此时的IP是19H  
        nop
    s:  
        mov ax,offset s              ;ax为0001h
        sub ax,ss:[0ch]              ;ax=1ah-19h=1
        mov bx,cs                    ;bx=cs
        sub bx,ss:[0eH]              ;bx=(bx)-(ss:[0eH])=> cs-cs=0
        
        mov ax,4c00H
        int 21H
code ends
end start
```

## call 和 ret 的配合使用
分析下面程序

```
assume cs:code
code segment
start:	mov ax,1
	    mov cx,3
     	call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp
     	
	    mov bx,ax	;（4）IP重新指向这里  bx = 8
     	mov ax,4c00h
     	int 21h
     s: add ax,ax
     	loop s;（2）循环3次ax = 8
	    ret;（3）return : pop IP
code ends
```
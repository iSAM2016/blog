- [1 HTTP WEB 的基础](#1-http-web-%E7%9A%84%E5%9F%BA%E7%A1%80)
- [2 URL与资源](#2-url%E4%B8%8E%E8%B5%84%E6%BA%90)
  - [2.1 报文流](#21-%E6%8A%A5%E6%96%87%E6%B5%81)
  - [2.2 报文组成详细解释](#22-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A)
    - [2.2.1 请求报文](#221-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)
      - [2.2.1.1 请求行](#2211-%E8%AF%B7%E6%B1%82%E8%A1%8C)
      - [2.2.1.2 请求首部](#2212-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8)
      - [2.2.1.3 Accept首部](#2213-accept%E9%A6%96%E9%83%A8)
      - [2.2.1.4 条件请求首部](#2214-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8)
      - [2.2.1.5 安全请求首部](#2215-%E5%AE%89%E5%85%A8%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8)
      - [2.2.1.6 代理请求首部](#2216-%E4%BB%A3%E7%90%86%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8)
      - [2.2.1.7 主体 [见下文]](#2217-%E4%B8%BB%E4%BD%93-%E8%A7%81%E4%B8%8B%E6%96%87)
    - [2.2.2 响应报文](#222-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)
      - [2.2.2.1 响应行](#2221-%E5%93%8D%E5%BA%94%E8%A1%8C)
      - [2.2.2.2 响应首部](#2222-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8)
  - [2.3 主体 [见下文]](#23-%E4%B8%BB%E4%BD%93-%E8%A7%81%E4%B8%8B%E6%96%87)
  - [2.4 其他首部介绍](#24-%E5%85%B6%E4%BB%96%E9%A6%96%E9%83%A8%E4%BB%8B%E7%BB%8D)
    - [2.4.1 通用首部](#241-%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8)
    - [2.4.2 实体首部](#242-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8)
    - [2.4.3 自定义首部](#243-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A6%96%E9%83%A8)
  - [2.5 主体](#25-%E4%B8%BB%E4%BD%93)
    - [2.5.1状态码](#251%E7%8A%B6%E6%80%81%E7%A0%81)
- [3 缓存](#3-%E7%BC%93%E5%AD%98)
  - [3.1 相关概念](#31-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5)
    - [3.1.1 缓存作用](#311-%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8)
    - [3.1.2 缓存命中](#312-%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD)
    - [3.1.3 新鲜度检查](#313-%E6%96%B0%E9%B2%9C%E5%BA%A6%E6%A3%80%E6%9F%A5)
    - [3.1.4 再验证命中或缓慢命中](#314-%E5%86%8D%E9%AA%8C%E8%AF%81%E5%91%BD%E4%B8%AD%E6%88%96%E7%BC%93%E6%85%A2%E5%91%BD%E4%B8%AD)
    - [3.1.5 缓存的拓扑结构：](#315-%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84)
    - [3.1.6 缓存的处理步骤](#316-%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4)
  - [3.2 缓存详细介绍](#32-%E7%BC%93%E5%AD%98%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D)
- [4 缓存的策略解释(重点)](#4-%E7%BC%93%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5%E8%A7%A3%E9%87%8A%E9%87%8D%E7%82%B9)




# 1 HTTP WEB 的基础
>[资料](https://segmentfault.com/a/1190000014134828)

*  MIME type： Web 服务器会为所有HTTP 对象数据附加一个MIME 类型中间由一个斜杠来划分

* URI: 统一资源标识符，我们通过他访问资源
    * URL: 统一资源定位符
    * URN: 统一资源名字（不常用）

* 方法
     * GET
     * PUT
     * POST
     * DELETE
     * POST
     * HEAD
  
* GET和POST 的区别

* 报文
    * 报文的种类
        * request message(请求报文)
        * response meassage(相应报文)
    * 组成格式
        * 起始行
        * 首部字段
        * 主体

* TCP/IP
>>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都
交给了通用、可靠的因特网传输协议TCP/IP。

* web的结构组件
    * 代理: 位于客户端和服务器之间的HTTP中间实体
    * 缓存（web cache）或代理缓存（proxy cache）： HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方,是一种特殊的代理
    * 网关：连接其他应用程序的特殊Web 服务器。
    * Agent： 代理发起自动HTTP 请求的半智能Web 客户端。

# 2 URL与资源

## 2.1 报文流

* 报文向下流动： 不管请求报文还是相应报文，所有的报文都会向下流动![]()
* 报文的组成部分
    * 起始行
    * 首部: http首部字段向请求和响应报文添加了一些附加信息。由“名/值”对组成，`应用程序也可以随意发明自己的所用首部`，组成： name:（空格）key，如下图
      * 通用首部（出现在请求、响应报文）
      * 请求首部
      * 响应首部
      * 实体首部
      * 扩展首部
    * 主体
        


## 2.2 报文组成详细解释

我们知道报文的组成是由`起始行、首部字段、主体`组成的，但是报文的种类是不同的，我们依次看

基本报文语法 

* `method:` 方法 
* `version:` http版本  
* `status:` 状态码 
* `reason-phrase:` 原因短读 
* `header:` 首部

### 2.2.1 请求报文

![基本格式](../../img/request.jpg)

#### 2.2.1.1 请求行

#### 2.2.1.2 请求首部
 
请求首部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求首部也有不同的含义

|   请求头   |                        说明                         |
| :--------: | :-------------------------------------------------: |
|    Host    | 接受请求的服务器地址，可以是IP:端口号，也可以是域名 |
| User-Agent |               发送请求的应用程序名称                |
| Connection |    指定与连接相关的属性，如Connection:Keep-Alive    |

#### 2.2.1.3 Accept首部

会使链接的两段都受益，客户端和得到他们想要的东西，拂去其不会浪费资源发送没用的东西。

|     请求头      |               说明               |
| :-------------: | :------------------------------: |
|     Accept      |          接受的媒体类型          |
| Accept-Charset  |   通知服务端可以发送的编码格式   |
| Accept-Encoding | 通知服务端可以发送的数据压缩格式 |
| Accept-Language |     通知服务端可以发送的语言     |

#### 2.2.1.4 条件请求首部

有时候希望客户端为请求加上某些限制，要求拂去其在对请求型芯响应之前，确保某个条件为真

|       请求头        |                            说明                            |
| :-----------------: | :--------------------------------------------------------: |
|       Expect        |           允许客户端列出请求所要求的服务器行为。           |
|      If-Match       |  如果实体标记与文档当前的实体标记相匹配，就获取这份文档。  |
|  If-Modified-Since  | 除非在某个指定的日期之后资源被修改过，否则就限制这个请求。 |
|    If-None-Match    | 如果提供的实体标记与当前文档的实体标记不相符，就获取文档。 |
|      If-Range       |             允许对文档的某个范围进行条件请求。             |
| If-Unmodified-Since | 除非在某个指定日期之后资源没有被修改过，否则限制这个请求。 |
|        Range        |       如果服务器支持范围请求，就请求资源的指定范围。       |


#### 2.2.1.5 安全请求首部

 http 本身可以进行询问/响应认证。这种响应要在客户端获取特定的资源之前。

|     首部      |                       描述                       |
| :-----------: | :----------------------------------------------: |
| Authorization | 包含了提供给服务器来对客户端进行自身认证的数据。 |
|    Cookie     |  它并不是真正的安全首部，但却是隐含了安全功能。  |
|    Cookie2    |         用来说明请求端支持的cookie版本。         |


#### 2.2.1.6 代理请求首部   


|        首部         |                                           描述                                            |
| :-----------------: | :---------------------------------------------------------------------------------------: |
|     Max-Forward     | 在通往源端服务器的路径上，将请求转发给其他代理或网管的最大次数----与 TRACE 方法一同使用。 |
| Proxy-Authorization |              Authorization 首部相同，但这个首部是在于代理进行认证时使用的。               |
|  Proxy-Connection   |                Connection 首部相同，但这个首部是在于代理建立连接时使用的。                |



#### 2.2.1.7  主体 [见下文]

### 2.2.2 响应报文

![基本格式](../../img/response.jpg)

#### 2.2.2.1 响应行

#### 2.2.2.2 响应首部

|       请求头       |              说明              |
| :----------------: | :----------------------------: |
|        Age         |      推算资源创建经过时间      |
|        ETag        |         资源的匹配信息         |
|      Location      |    令客户端重定向至指定URI     |
| Proxy-Authenticate |  代理服务器对客户端的认证信息  |
|    Retry-After     |    对再次发起请求的时机要求    |
|    Server HTTP     |        服务器的安装信息        |
|   Accept-Ranges    |      是否接受字节范围请求      |
|        Vary        |    代理服务器缓存的管理信息    |
|  WWW-Authenticate  |    服务器对客户端的认证信息    |
|       Server       | 服务器应用程序软件的名称和版本 |


## 2.3 主体 [见下文]    

## 2.4 其他首部介绍

### 2.4.1 通用首部

通用请求比较少。一般是Date，Cache-Control或Connection。通用的缓存首部

|    请求头     |             说明             |
| :-----------: | :--------------------------: |
|     Date      |             时间             |
| Cache-Control |    用于随报文传送缓存指示    |
|    Pragma     | 另一种用于随报文传送缓存指示 |

### 2.4.2 实体首部 
 * *内容首部*

|      请求头      |             说明             |
| :--------------: | :--------------------------: |
| Content-Encoding |    实体主体适用的编码方式    |
| Content-Language |      实体主体的自然语言      |
|  Content-Length  | 实体主体的大小（单位：字节） |
| Content-Location |      替代对应资源的URI       |
|   Content-MD5    |      实体主体的报文摘要      |
|  Content-Range   |      实体主体的位置范围      |
|   Content-Type   |      实体主体的媒体类型      |

 * *实体缓存首部*

|    请求头     |          说明          |
| :-----------: | :--------------------: |
|     ETag      |  与实体相关的实体标注  |
|    Expires    | 实体主体过期的日期时间 |
| Last-Modified | 资源的最后修改日期时间 |

在缓存章节我们重点介绍

### 2.4.3  自定义首部

上文提到过我们可以自定义首部，自定义首部可以让前台和后台进行特殊的通信，但是需要后台的一些配合。
我们前台定义了特殊的头部
```
//client/index.js

let myHeaders = new Headers({
    'X-Custom-Info': "isam2016" // 自定的请求头
});
```

如果没有后台的支持会报错

![](../../img/custom.png)

后台支持
```
//设置跨域访问  
app.all('*', function(req, res, next) {
  res.header("Access-Control-Allow-Headers", "X-Custom-Info");
  next();
});
```

## 2.5 主体
>位于首部行之后

实体包含了Web客户端请求的对象。当Web服务器接收到Web客户端的请求报文后，对HTTP请求报文进行解析，并将Web客户端的请求的对象取出打包，通过HTTP响应报文将数据传回给Web客户端，如果出现错误则返回包含对应错误的错误代码和错误原因的HTTP响应报文。

![](../../img/body.png)

###  2.5.1状态码

 [HTTP返回码中301与302的区别](https://blog.csdn.net/qmhball/article/details/7838989)

| 总体范围 | 已定义范围 |       类别 |
| -------- | :--------: | ---------: |
| 100~199  |  100~101   |       信息 |
| 200~299  |  200~206   |       成功 |
| 300~399  |  300~305   |     重定向 |
| 400~499  |  400~415   | 客户端错误 |
| 500~599  |  500~505   | 服务器错误 |
  
**我们重点关注的是3开头的状态码**

| 状态 | 原因短语           |                                         含　　义                                          |
| :--- | :----------------- | :---------------------------------------------------------------------------------------: |
| 300  | Multiple Choices   |           多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。            |
| 301  | Moved Permanently  |          请求的URL已移走。响应中应该包含一个LocationURL，说明资源现在所处的位置           |
| 302  | Found              | 与状态码301 类但这里的移除是临时的。客户端应该用Location 首部给出的URL 对资源进行临时定位 |
| 303  | See Other          |        告诉客户端应该用另一个URL 获取资源。这个新的URL 位于响应报文的Location 首部        |
| 304  | Not Modified       |       客户端可以通过它们所包含的请求首部发起条件请求。这个代码说明资源未发生过变化        |
| 305  | Use Proxy          |                 必须通过代理访问资源，代理的位置是在Location首部中给出的                  |
| 307  | Temporary Redirect |         和状态码301 类似。但客户端应该用Location 首部给出的URL 对资源进行临时定位         |

* 永久搬离的资源

    资源可能被移动到新的位置，或者被重新命名，有了一个新的URL.web服务器可以告诉客户端资源已经被重新命名了。这样客户端就可以从新的地址获取资源之前，更新数钱之类的信息了。状态码301就是这个作用

* 临时搬离资源

    如果资源被临时移走或重命名, 服务器可能希望将客户端重定向到新的位置上去。但由于重命名是临时的，所以服务器希望客户端将来还可以回去使用老的URL,不要对书签进行更新。状态码301 和 307

* URL增强

    服务器通常用重定向来重写URL，往往用于嵌入上下文。当请求到达时，服务器会生成一个新的包含了嵌入式状态信息的URL，并将用户重定向到这个新的URL上去。客户端会跟随这个重定向信息，重新发起请求，但这次的请求会包含完整的、经过状态增强的URL。这是在事务间维护状态的一种有效方式。状态码"303 See Other"和"307 Temporary Redirect"用于此类重定向。

* 负载均衡 
    
    如果一个超载的服务器收到一条请求，服务器可以将客户端重定向到一个负载不太重的服务器上去。状态码"303 See Other"和"307 Temporary Redirect"可用于此类重定向。

* 服务器关联
 
    Web服务器上可能会有某些用户的本地信息；服务器可以将客户端重定向到包含了那个客户端信息的服务器上去。状态码"303 See Other"和"307 Temporary Redirect"可用于此类重定向。

* 规范目录名称

    客户端请求的URI是一个不带尾部斜线的目录名时，大多数Web服务器都会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作了。

# 3 缓存

## 3.1 相关概念

>[浏览器的协商缓存与强缓存](http://caibaojian.com/browser-cache.html)

### 3.1.1 缓存作用
    
    缓存减少了冗余数据传输，缓解了网络瓶颈问题，降低了对原始服务器的要求，降低了延时距离，如何衡量其有效性及将缓存置于何处可以发挥最大的作用。还用缓存检查新鲜度的问题

### 3.1.2 缓存命中
    
    可以使用已有的副本为某些达到缓存的请求提供服务，这被称为缓存命中。其他一些达到花村的请求可能会由于没有副本可用，而被转发给原始服务器。被称为缓存未命中。

### 3.1.3 新鲜度检查

    原始服务器的内容可能会法伤变化，缓存要对其进行检测，看看他们保存的副本是否是服务器上最新的副本。

### 3.1.4 再验证命中或缓慢命中
  
    缓存对缓存的副本进行再验证时候，会向服务器发送一个小的再请求验证，如果内容没有变化，服务器会以一个小的304（NOT Modified）进行响应。只要缓存知道副本任然有效，就会再次将副本标记为暂时新鲜的，并将副本提供给客户端.Http提供了几个工具，用的最多的是if-Modified-Since。在请求中添加该字段，告诉服务器只有在缓存了对象的副本之后，又对其进行的修改情况下才发送对象

### 3.1.5 缓存的拓扑结构：

* 私有缓存：一般是我们的浏览器
* 公有缓存：（代理缓存,不做讨论）

### 3.1.6 缓存的处理步骤

1. 接收- 缓存从网络中读取抵达的请求报文

2. 解析- 缓存对报文进行解析，提取出url和各种首部

3. 查询- 缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）

4. 新鲜度检测- 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何的更新

5. 创建响应- 缓存回会用新的首部和已缓存的主体来共偶见一天响应报文

6. 发送

7. 日志

![处理一个新鲜的缓存命中](../../img/cache.jpg)

![处理一个新鲜的缓存命中](../../img/progress.jpeg)


## 3.2 缓存详细介绍

现在看来，缓存部分有些疑惑，条理不清楚，请仔细阅读HTT缓存控制小结

* [通过express框架简单实践几种设置HTTP对缓存的控制](https://www.jianshu.com/p/3bc803a4313f)

* [HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)

* [《图解HTTP》笔记——HTTP首部(通用请求与客户端请求)](http://blog.csdn.net/qq_34289537/article/details/52971516)

* [http状态码301和302详解及区别——辛酸的探索之路](http://blog.csdn.net/grandPang/article/details/47448395)

* [HTTP 首部字段详细介绍](http://www.cnblogs.com/jycboy/p/http_head.html)

![](../../img/caches.png)

**说明：**

    Expiresf相比，Cache-control 更加，精准控制缓存，并且有更高的优先级

    浏览器在Cache-control 指定no-cache或者max-age和Expires均过期之后，将Etag值通过If-none-match作为请求首部发送给服务器，服务器接受到请求之后，对比所请求资源的Etag值是否改变，如果未改变则返回304 Not Modified, 并且根据既定的缓存策略分配新的Cache-control 信息； ...

    如果强制浏览器使用协商缓存策略，需要将Cache-control 首部信息设置为no-cache,这样不会判断max-age 和 Expires 过期时间，从而每次资源请求都会经过服务器对比。

**补充**

web缓存的种类

* 1 数据库缓存

　　我们可能听说过memcached，它就是一种数据库层面的缓存方案。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。

* 2 CDN缓存

　　CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。

* 3 代理服务器缓存

　　代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。

* 4 浏览器缓存

　　每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。

* 5 应用层缓存

　　应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。

# 4 缓存的策略解释(重点)

* [浏览器的协商缓存与强缓存](http://caibaojian.com/browser-cache.html)
* [cache 细节，缓存整体流程和细节](https://juejin.im/entry/58579599b123db00658292a0)

在阅读相关的文章的时候，我们看到缓存策略是个倒三角，对应的作用是不同的。从上到下可以概括为：

* 缓存存储策略
* 缓存过期策略
* 缓存对比策略


* 缓存存储策略

这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端

对于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据

通过 Cache-Control：Public 设置我们可以将 Http 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借助一套鉴别机制来确认才行， 这就是我们下面要讲到的“缓存过期策略”。

* 缓存过期策略

这个策略的作用也只有一个，那就是决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）

刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。

不过 Http 缓存头设计并没有想象的那么规矩，像上面提到的 Cache-Control（这个头是在Http1.1里加进来的）头里的 no-cache 和 max-age 就是特例，它们既包含缓存存储策略也包含缓存过期策略，以 max-age 为例，他实际上相当于：

Cache-Control：public/private（这里不太确定具体哪个）
Expires：当前客户端时间 + maxAge 。
而 Cache-Control：no-cache 和 Cache-Control：max-age=0 （单位是秒）相当




